<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[URI 与 URL 的区别]]></title>
      <url>%2F2017%2F09%2F13%2FURI-%E4%B8%8E-URL-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[1. 定义：URI: Uniform Resource Identifier，统一资源标识符 URL: Uniform Resource Location，统一资源定位符 URI 是一个用于标识某一互联网资源名称的字符串。这种标识允许用户对网络中的资源通过特定的协议进行交互操作。URI 的最常见的形式是 URL，经常指定为非正式的网址。更罕见的用法是 URN（统一资源名称），其目的是通过提供一种途径。用于在特定的命名空间资源的标识，以补充网址。 通俗来讲，URL 和 URN 是 URI 的子集，URI 属于 URL 更高层次的抽象，一种字符串文本标准。 三者关系如下图： 2.区别URI 只是起到一种标识作用即可，并不一定非要指出访问这个资源的路径，以及如何访问。而 URL 就必须指出访问协议 ，访问路径 。打个比方，要唯一表示一个人，可以用身份证号来表示，这可以说是 URI，但不能说是 URL，但是如果采用这个人的家庭住址来表示，这可以说是 URL 也可以说是 URI。所有的 URL 都是 URI，但是并非所有的 URI 都是 URL。 下面看看具体的例子： ftp://ftp.is.co.za/rfc/rfc1808.txt (also a URL because of the protocol) http://www.ietf.org/rfc/rfc2396.txt (also a URL because of the protocol) ldap://[2001:db8::7]/c=GB?objectClass?one (also a URL because of the protocol) mailto:John.Doe@example.com (also a URL because of the protocol) news:comp.infosystems.www.servers.unix (also a URL because of the protocol) tel:+1-816-555-1212 telnet://192.0.2.16:80/ (also a URL because of the protocol) urn:oasis:names:specification:docbook:dtd:xml:4.1.2 这些都是 URI，但是只有提供了访问协议的才是 URL。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP 学习]]></title>
      <url>%2F2017%2F08%2F28%2FHTTP-%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[1. HTTP 请求报文格式请求行、请求头、请求体 请求行：请求方法、请求地址、协议版本 请求方法：GET、POST、DELETE、PUT 比较常用 请求地址：URL 组成 PATH 是 URL 主机以后的部分，即包含了Query String。 2. HTTP 相应报文格式响应状态行、响应头、响应体 3. HeaderHeader 可用于传递一些附加信息，格式：键: 值 ，注意：冒号后面有一个空格 12Content-Length: 1024Content-Type: text/plain 4. 请求体的 3 种形式 移动开发者常见，请求体是任意类型，服务器不会解析请求体，请求体的处理需要自己解析，如 POST JSON 时候就是这类 第二种和第三种都有固定格式，是服务器端开发人员最先了解的两种。这里的格式要求就是 URL 中的 Query String 的格式要求：多个键值对之间用 &amp; 连接，键与值之间用 = 连接 第三种请求体的请求体被分成为多个部分，文件上传时会被使用，这种格式最先应该是被用于邮件传输中，每个字段/文件都被boundary（Content-Type中指定）分成单独的段，每段以-- 加 boundary开头，然后是该段的描述头，描述头之后空一行接内容，请求结束的标制为boundary后面加-- 4. TCP 协议的三次握手与四次挥手TCP 协议作为底层的传输协议，在进行数据连接是，客户端和服务端要进行三次握手才能保证 client 与 server 能互相相应；在数据传输完成后，需要断开连接，要进行四次挥手，才能断开连接。 5. 计算机网络的一些基本知识计算机网络从下到上分为7层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 IP协议 位于网络层 TCP协议/UDP协议 位于传输层 HTTP协议 位于应用层 Socket 不是一种协议，而是对 TCP/UDP 协议的一种封装，对外提供了 API 接口，方便调用 HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。 TCP/UDP 区别： TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上（实际上也很大程度上保证了）保证了连接的可靠性；而UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议。 也正由于1所说的特点，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。 知道了TCP和UDP的区别，就不难理解为何采用TCP传输协议的MSN比采用UDP的QQ传输文件慢了，但并不能说QQ的通信是不安全的，因为程序员可以手动对UDP的数据收发进行验证，比如发送方对每个数据包进行编号然后由接收方进行验证啊什么的，即使是这样，UDP因为在底层协议的封装上没有采用类似TCP的“三次握手”而实现了TCP所无法达到的传输效率。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git常用命令]]></title>
      <url>%2F2017%2F07%2F16%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[配置信息 全局配置个人信息，如果想只配置本项目的信息，去掉--global git config --global user.name yourname git config --global user.email youremail 提高工作效率的方式，别名配置 git config --global alias.别名 原始命令 git config –global alias.co checkout 配置高亮显示 git config --global color.status auto 查看状态高亮显示 git config --global color.branch auto 分支名高亮 git confit --global color.ui auto 自动高亮 基础命令 git init 初始化 git status 查看状态 git add 文件名 添加文件到暂存区 git add . 添加当前目录下所有文件到暂存区 需注意的是，git add 命令不是执行一次就可以，每次修改项目内容后，都需要执行 git add 命令进行更新 git commit -m 通过 -m 添加提交的简短信息 查看项目历史记录 git log 下载程序 git clone yourProjectUrl 不同分支 当你需要开发一个新功能时，可以新建一个新的分支，并且切换到该分支开发，当功能完成后，你将该分支提交到本地，然后再切换到主分支并且合并，完成新功能的开发 git branch yourbranchName 创建一个新的分支 git branch 查看当前所有分支 git branch -d 分支名 删除某一分支 注意，不能在本分支删除本分支，必须切换到其他分支 git checkout yourbranchName 切换到一个分支 git checkout yourProjectName 回滚操作，将文件回滚到最近一次提交的状态 合并分支 假设我们新开一个分支 net 新增一个功能，开发成功了，我们需要将新功能合并到 master 分支，如果没有冲突，那么 net 分支将与 master 分支合并 git merge net 解决冲突 git merge 中，如果没有冲突，才会自动合并，否则将会提出哪些文件产生了冲突。产生冲突的原因是因为很多个开发人员修改了同一个文件的相同地方导致，导致 Git 系统不知道用谁的代码，此时就需要开发人员自己选择，选择其中一份代码，并且将其他的代码删除。当然也得将&lt;&lt;&lt;&lt;&lt;&lt;HEAD 和 ========= 之类的冲突标识删除，然后重新 add commit 即可以提交 为版本打一个标签 在完成所有功能，并且经过测试后，我们通常会为这个版本打一个标签，这是一个非常重要的功能，便于后续版本检索与维护 git tag -a v1.o -m 后面加简短的信息 git tag -d 标签名 来删除标签 git show 标签名 查看该分支的具体信息 同远程 Git 仓库交互 将本地仓库的代码提交到 Git 仓库 git remote add origin 你的git仓库地址 origin 是给远程 Git 仓库起的一个别名，通常都这样起，然后将项目与该远程仓库关联 注意：一个项目可以和多个远程仓库关联的，这样就可以在 push 或者 pull 时选用不同的远程仓库名进行操作 git push resp br 将项目推送到远程仓库 resp: 远程仓库名 br: 远程仓库的一个分支 git push origin master : master 第一个 master 是本地仓库的分支，第二个是远程仓库的分支，如果两个仓库的分支一样，可以简化为 git push origin master git push orign : net 删除 origin 远程仓库的 net 分支 更新最新的代码 一般的话，先从远程仓库的代码 pull 到本地，确保合并成功，如果有冲突，要解决好冲突，然后再将本地代码 push 到远程仓库 git pull resp br git pull origin msater 遇到的几个问题 在 pull 的时候，因为两个仓库不同，出现了refusing to merge unrelated histories 问题，解决办法是：git pull origin master --allow-unrelated-histories 即可将远程代码 pull 下来 但是，在合并的时候又出现了一个非要让你写 message 的框框，解决办法为 1.按键盘字母 i 进入insert模式 2.修改最上面那行黄色合并信息,可以不修改 3.按键盘左上角”Esc” 4.输入”:wq”,注意是冒号+wq,按回车键即可 可以直接执行 3、4 步即可 Fork + Pull Request 多人协作模式先 Fork 一份到自己的仓库，这个派生系统没有独立的缺陷追踪系统，必须利用原来项目的缺陷追踪系统。 然后 clone 到本地，在修改完成后，先提交到自己的本地仓库，通过Pull Request 方式，将自己的代码请求更新到原仓库。如果原仓库的主人同意了请求，主仓库就会合并了代码，使项目变得更加稳定、强大。 但是，在 Pull Request 之前，要首先从原仓库把最新的代码 Pull 下拉，以免改动了同一个地方，引起冲突，如果有冲突，解决冲突，然后再提交到自己的远程仓库，通过 Pull Request 向原仓库提交代码合并的请求。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Kotlin 学习笔记（一）环境配置]]></title>
      <url>%2F2017%2F05%2F23%2FKotlin-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[在前面说几句Google I/O 正式宣布将 Kotlin 作为 Android 的官方开发语言，大家学习 Kotlin 的热情瞬间高涨。今天就给大家分享点开发 Kotlin 的环境配置经验。虽然简单，但还是有一点坑。 安装插件 直接在 setting -&gt; plugin 里面搜索 Kotlin 安装后重启 AS，这样就集成了开发 Kotlin 的最基础的环境，对了不要忘记配置 Kotlin 的依赖，可以用插件一键自动生成 Tools -&gt; Kotlin -&gt; Configure Kotlin in Project ，然后 sync gradle 即可。 我是看 Kotlin For Android Developer 中文译文搭建的，里面要求在安装一个叫Kotlin Extensions For Android 的一个插件，它的作用是摆脱 findViewById() 的烦恼，可以直接引用 xml 的 id，作为变量名称。可是我怎么都找不到这个插件，在 JetBrans 官网也找不到，不知道是怎么回事。但是似乎仍能导入相应的包import kotlinx.android.synthetic.main.activity_main.* ，本以为难道两个插件功能叠加起来了，但在编译的时候还是出错了，unresolved reference kotlinx 找不到 kotlinx 的引用，在 Google 之后，终于解决了这个问题。 在 project level 的 gradle 下添加如下代码： 123456&gt; buildscript &#123;&gt; dependencies &#123;&gt; classpath "org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version"&gt; &#125;&gt; &#125;&gt; &gt; 在 app level 的 gradle 下添加如下代码： 12&gt; apply plugin: 'kotlin-android-extensions'&gt; 最终，我没有下载 Kotlin Extensions For Android 这样个插件，而是通过手动添加 gradle 代码解决了这个问题。 暂时不推荐安装anko 插件，安装后，重新启动 AS 时，会出现打不开的现象，这样就很烦。 总结官网上说是，AS 3.0 会直接集成 Kotlin，但是 3.0 好像没放出来。配置环境就是安装插件的问题，坑可能还有不少，一步步来填吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[鉴势平板开发总结]]></title>
      <url>%2F2017%2F05%2F17%2F%E9%89%B4%E5%8A%BF%E5%B9%B3%E6%9D%BF%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[写在前面的话大概花了 10 天左右的时间，完成了「鉴势」平板的开发工作，整体难度到没有多大，但还是学习并巩固了不少知识，在此记录。 界面布局 第一次做这种表格类型的 APP，也没想太多，直接把表格的线一个个的 View 画出来了。着重使用 weight 属性，能简化不少问题。画表格线，可以通过设置背景来实现，这样应该会简单一点。tablelayout 也可以尝试一下。 应对这种多控件的布局，ButterKnife 必不可少，如果嫌这个也慢的话，也可以使用自动生成ButterKnife 注解的插件ButterKnife Zelezny ，显著提高生产效率。 id 命名：感觉我命名的有点长，但感觉这样才好分辨。 资源管理 由于使用的常量太多，建立一个常量类 颜色、尺寸、字符串资源统一管理 DatePickerDialog熟悉了这个原生的日期选择控件，也可以使用DialogFragment 的方式来管理对话框（暂未实现）。 Spinner熟悉了这个原生的下拉列表控件，使用了最简单的设置字符串数组的方式来实现。也可以自己设置adapter ，自定义列表的样式。 Android 数据持久化技术 SQLite 3：这个项目使用了 SQLite 存放了一张 user 表，用于用户的注册和登录。了解了基本的 SQLite 操作，安装了一个 SQLite 可视化工具。 SharedPreference：一种轻量级的 Android 存储数据的方式，以键值对的方式保存，通过这个东西，实现了记住密码的操作。 Java I/O 流感觉自己还不是很熟悉，基本知识还要加强。 1234567891011121314private void writeScada(String content) &#123; File file = getContext().getExternalFilesDir(Environment.DIRECTORY_DCIM); BufferedOutputStream bos = null; try &#123; bos = new BufferedOutputStream(new FileOutputStream(new File(file, "SCADA 系统信息安全自查表.doc"))); bos.write(content.getBytes()); bos.flush(); bos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 其他这次采用了按功能分包的方式，感觉比以前功能拆分更加清晰。 后记这次开发，发现自己很多基础的东西都掌握的不太好，这是以后需要着重加强的一点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HelloWorld 社团一年总结]]></title>
      <url>%2F2017%2F04%2F21%2FHelloWorld-%E7%A4%BE%E5%9B%A2%E4%B8%80%E5%B9%B4%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[时间过得真快，好像从去年当上 Android 组长，到现在要换届，真的只是一眨眼的功夫。但时间就是这样的，从自己出生到现在，何尝不是一眨眼的功夫呢？也许只有自己最清楚，自己这一年成长了多少，进步了多少。从大一的懵懵懂懂，学习课堂上的知识，到现在有选择性的逃课，做自己喜欢的事；由大一的有点放不开，到现在的乐观、开朗、脸皮超厚……谁知道我经历了什么（哈哈）。我想这就是成长，我喜欢这种感觉，也会慢慢变成自己心目中理想的模样。 好像是要说社团经历啊，按着时间线来吧。最初选择当 Android 组长的初衷，我还记得：有这个身份做驱动，快速提高自己的 Android 开发技术。大一的时候，确实我们社团 Android 学习的氛围几乎为 0 ，也没有系统的学习相关知识，Java 基础 和一些 Android 基础都不过关。于是在大一的那个暑假，我开始了恶补，学习了 Java 和 Android 的一些基础知识。同时，在那个暑假的时候，还给大二的同学布置了学习任务，每周还要收他们的学习汇报（大多数情况都是我主动去问他们要，wuwu~）。体会到了身为 Android 组长责任感，同时看到他们的学习进度，也会激励自己去学习，那时候主要看视频，也算是浅浅的入门了吧，不过只会敲 demo，对一些基础的知识有了了解。 暑假休息完，社团第一次开会，我记得王琦问我们「暑假干了什么？」那会感觉回答个问题都会有点紧张，感觉还是没有融入社团，那会王琦好像也有点「严肃」，或许是吧。不过现在，社长真是变了很多，从大一时见到她的少言寡语，到现在的整个人的提高，很有思想。说自己吧，就开会这件事，上学期的话，首先是招新的事，然后呢就是问 Android 组的学习情况，下学期基本上没啥事了，大部分是行政方面的。基本上每周一次的会议，坚持了整整两个学期，当真不容易。首先我们大二这波人，真的还不错，不说技术方面，这种责任感也是不容易的。主席团的三位领导也是很辛苦，都是责任感啊，上一届的社团办的很不错，「不要毁掉江山」可能是很大的驱动吧。 招新的话，我也不知道到底自己的选择是否正确，也不知道自己培养他们的方法是否合适，但我始终认为一条准则，真正想学的人，一定会自己找资源，找方法，主动找我求教的，这是最基础的自学能力。当然，我也尽量为他们提供了足够的资源与氛围，什么学习资料，要求他们一周在群里说一下本周总结（虽然慢慢地不做了），开会教他们一些基础的知识，尽量让他们少走弯路，当然也会告诉他们一些框架什么的，最后我给他们布置了一个做一个「阅读类 APP」的任务，如果他们能做出来，能力肯定能进步一大截。MVP + RxJava + Retrofit，再加上 Material Design 的设计，一定会给自己一个满意的交待的。不过，这个学期，由于自己也一直在忙，准备各种比赛，只开过一次会，我想还会最后再开一次吧。现在估计他们进度不会太好，最后开会的时候再和他们说一下吧。这算是一种遗憾吧，不过自己确实在忙的过程中提高了很多，不管是技术还是为人处事。 这个学期，我们社团的活动较少，没有怎么出去玩，去过浙工大一次（但没有看到所谓的小和山），看过次电影，出去聚过餐吧。以后活动还是要多一点，否则还是玩不到一块的。 社团的话，要做活动，摆摊是很重要的一部分，我自己对行政什么的不感兴趣，也没有怎么参与。只是听命令去摆摊就好了，不过我想着不要为了摆摊而摆摊，比如今天的「后续宣传」，真的没什么用，我们这个类型的沙龙，其实通过摆摊去听的真是没几个，也不需要多少人去听。或许是为了让同学知道我们社团办了这个活动，前期宣传是很重要的，但是后续宣传真是没啥用。就算有人知道了，到下个学期不就忘了吗？我们还是要宣传呀，只有摆摊人员干坐在那里。感觉，今年的摆摊没有大一的 Hackthon 的那种激情。 关于社团管理方面，现在我们的层级结构是 主席团 - &gt; 组长、部长 - &gt; 小干事。算是比较传统的架构吧，两头的结构我觉得没啥好变的，主要是中间这层，这个学期，每个组的都在自己的小圈子里学习。真正要做项目的时候，必然是很多组一起干的，前端、移动开发组不知道如何和后台交互，后台也不知道自己学的到底有什么用。希望下一届在技术部这块一定要好好想想，给干事们找活干。感觉还是需要一个技术部长，定义举行社团内的技术沙龙，各组长也可以去演讲，在这个氛围下，给真正想学技术的同学提供一条途径吧。在组长的就任仪式上，罗峡说过，「这个社团已经成为生活中不可缺少的一部分」，我想那是的为并没有这种感觉，主要是社团的 Android 技术氛围并不好，也没真正学到什么东西。而前端的大神很多，他也有机会得到更多交流和进步的机会。我想通过这种沙龙和项目活动，增强干事的社团归属感吧。不过，看似前景很不错，但真正执行起来还是有很多阻碍的。 社长，真是我很钦佩的一个人，可能在她身上能看到自己的一点影子吧。一点点的改变自己，一点点的成长，不过她在管理社团方面真是很棒。我的话，差选了，管理也真是一门学问呢。以后也努力提高吧。以后一定会在路上看到你打招呼的。哈哈。 忘了，作为 Android 组长，这个身份也让我认识了不少人，交了一些志同道合的朋友，给了我很多帮助。这些看不见的东西，我觉得可能是最重要的。 最后总结一下吧，一年的 Android 组长的身份，暑假学习、收学习汇报、招新、讲课、开会、摆摊、办活动、出去玩，大概就这样吧。总体来说，自己还是得到了很多，不知道给社团贡献了多少，给自己勉强打个 80 分吧。自己技术得到了提高，为人处事也有了一些进步，成长了不少。不后悔当这一年的 Android 组长。由于对社团管理没啥兴趣，还是想继续提高技术，所以我打算不留了。不过，社团的话，也可以留下我的名字，有什么需要帮忙的，我也一定会尽力去做的。 做自己喜欢的事 —— 生活就是这么简单。 田浩宇 2017.4.22]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 回调机制理解]]></title>
      <url>%2F2017%2F04%2F16%2FAndroid-%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[前言经常听什么「回调」啊，Android 框架里什么生命周期啊，各种监听事件啊，直白一点，各种带「on」的方法，都是「回调方法」，一直想了解，但是一直没理解清楚。现在参考了网上的一些例子，梳理一下。 PS：首先要清楚 Java 中接口的相关概念，其次要有一点「事件分发机制」的了解（暂时还没弄清楚，以后写博客总结）。 概念A 类中定义一个方法，这个方法中用到一个接口变量和该接口中的方法，但这个接口中的抽象方法需要 B 类去实现，B类实现该方法后，它本身不会调用该方法，而是传递给 A 类，供 A 类调用，这种机制称为「回调」。 实战下面我们拿 button 的点击事件来分析模拟： 首先，在 View 类中，找到interface OnClickListener ： 123public interface OnClickListener()&#123; void onClick(View var);&#125; 这是定义的接口，然后还有对应的接口变量：public OnClickListener mOnClickListener 。 其次，在 View 类中我们能找到 setOnClickListener(OnClickListener l) 方法： 123456public void setOnClickListener(OnClickListener l)&#123; if(!isClickable())&#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l;&#125; 该方法中，将 OnClickListener l 赋值给了 成员变量 mOnClickListener。 我们继续往下找，找到在 performClick() 方法中，执行了我们的onClick() 方法。 12345678910public boolean performClick() &#123; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); return true; &#125; return false; &#125; 这就是概念中所说的，A 类中接口变量调用抽象方法的方法，也就是 B 类回调 A 类的方法。 在某一个 Activity 中，实现 button 的点击事件。 123456button.setOnClickListener(new OnClickListener&#123; @Override public void onClick(View view)&#123; //做具体的操作 &#125;&#125;); 这里就将一个接口的实现类作为参数传入 View 类中的 setOnClickListener() 方法中，从而为 View 类中的 成员变量 mOnCLickLisetener 赋值。 接着就是在父类中，也就是 View 类中执行 onClick() 方法，为什么会在父类中执行该方法呢？这就要说到 Android 中的另一个重要的机制——「事件分发机制」。当我们手指触摸到手机屏幕，就一定会执行dispatchTouchEvent(MotionEvent event) 方法。（此处省略10000字） 简单点说就是：通过事件分发机制，最终调用了performClick() 方法，从而执行了onClick() 方法。 123if(!post(mPerformClick))&#123; performClick();&#125; 为什么要回调这里体现了Java 中的「万事万物皆为对象」的理念，我们需要将普通物体的特性抽象出来，共性之中又有特性，每种特性交由不同的情况处理，通过接口暴露的方法可以减少很多重复，代码更加优雅。 例如：Button 和 TextView 都继承于 View，在做点击事件时，点击的具体逻辑是不同的。我点Button 可能弹出一个 toast，而点击 TextView 弹出一个 Notifaction，这时候回调的好处就体现出来了，因为 Android 对外暴露了 onClickListener() 接口，里面要去具体实现 onClick() 方法，就在这我们就可以随意定制了。而 View 的话，不管你如何实现，它只负责调用 onClick() 方法。 这样，代码更加简洁，逻辑也更加清晰，也算多态的一种实现吧。 参考文章Android 中的回调函数机制解析 android 中的回调 Android 回调函数机制那点事]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 接口深入理解]]></title>
      <url>%2F2017%2F04%2F16%2FJava-%E6%8E%A5%E5%8F%A3%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[直观印象 抽象方法的集合，是一种对行为的抽象 是一种程序之间的一种「协议」或者「规范」 实现「多态」的一种手段 注意事项 接口本身不是「类」，我们不能实例化一个接口，如 new Runnable() 肯定是错误的，我们只能 new 它的实现类。 interface 的所有方法访问权限自动被声明public 及 abstract 。确切的说，只能声明为public 和 abstract 。 接口中可以定义「成员变量」，或者说是不可变的常量，因为接口中的「成员变量」会自动变为public static final 。可以通过实现类名直接访问ImplementClass.name 。 接口中不存在实现的方法。 实现接口的非抽象类 必须要实现该接口的所有方法。抽象类可以不用实现。 不能使用new 操作符来实例化一个接口，但可以声明一个接口变量，该变量必须引用一个实现该接口的实现类。 实现多接口的时候一定要避免方法名的重复。 为什么要使用接口 接口是一种规范，一种「招牌」，便于查看，便于维护和拓展 知乎上详细的例子 接口就是个招牌。 比如说你今年放假出去杭州旅游，玩了一上午，你也有点饿了，突然看到前面有个店子，上面挂着KFC，然后你就知道今天中饭有着落了。 KFC就是接口，我们看到了这个接口，就知道这个店会卖炸鸡腿（实现接口）。 那么为神马我们要去定义一个接口涅，这个店可以直接卖炸鸡腿啊（直接写实现方法），是的，这个店可以直接卖炸鸡腿，但没有挂KFC的招牌，我们就不能直接简单粗暴的冲进去叫服务员给两个炸鸡腿了。 要么，我们就要进去问，你这里卖不卖炸鸡腿啊，卖不卖汉堡啊，卖不卖圣代啊（这就是反射）。很显然，这样一家家的问实在是非常麻烦（反射性能很差）。 要么，我们就要记住，中山路108号卖炸鸡，黄山路45号卖炸鸡（硬编码），很显然这样我们要记住的很多很多东西（代码量剧增），而且，如果有新的店卖炸鸡腿，我们也不可能知道（不利于扩展）。 接口实现多态 知乎上详细的例子 接口的作用对于很多新手来说很不容易理解，我给大家举个例子。接口只是一个规范，所以里面的方法都是空的。假如我开了一个宠物粮店，声明所有宠物都可以来我这里买粮食，这就相当于一个接口， public interface PetRestaurant { public void buy();} 当一只狗看到了，知道自己是宠物，所以它去实现这个接口public class DogPet implements PetRestaurant { @Override public void buy() { System.out.println(“我是狗，我要买狗粮”); }}当一只猫看到了，知道自己也是宠物，所以也去实现这个接口public class CatPet implements PetRestaurant { @Override public void buy() { System.out.println(“我是猫，我要买猫粮”); } }当狗和猫来我的店之前，我是不知道他们到底是什么，但是当他们来到我的店，我就知道一个要猫粮食，一个要狗粮食。因为他们都实现了 我这个接口，都可以买。下面这个类相当于一个接待顾客的类，即店小二，他接待所有实现了我这个宠物店接口的动物，传进来一个PetRestaurant 类型的宠物，注意，这个PetRestaurant 是接口public class test { public void buy(PetRestaurant pet) { pet.buy(); }} 好了，这个时候我这个老板出现了，我可以给他们卖粮食了，相当于测试类public class Tests { public static void main(String[] args) { PetRestaurant dog = new DogPet(); //实例化一个狗，相当于把狗顾客实例化 PetRestaurant cat = new CatPet();//实例化一个猫，相当于把猫顾客实例化 test t = new test(); //实例化一个店小二 t.buy(cat); //把猫交给店小二 t.buy(dog); //把狗交给店小二 } }这样运行的结果就是我是猫，我要买猫粮我是狗，我要买狗粮 你知道吗，整个过程我这个店主其实根本不知道来的到底是猫是狗还是其他什么，我只要有一个店小二，把这些来的不知什么动物都全部交给店小二，店小二就知道怎么去卖了，因为这些狗啊猫啊都实现了我这个宠物店的接口，而店小二就负责接待所有实现了我这个接口的动物。这就有一个好处，假如明天来了一头小猪，只要它实现了我这个接口，我只管交给店小二处理就OK了，我这个店小二根本不需要变化，我这个店主也只需要实例化一下这个动物就OK你想，假如没有接口，会怎么办，来一个猫，我要去创造一个猫，还要实例化，来一只狗，我要创建一只狗，同样要实例化，还要配备专门的店小二去接待，就会相当麻烦。 接口和抽象类的区别 语法层次 抽象类实现 1234567public abstract class Demo&#123; abstract void method1(); void method2()&#123; // 可以实现 &#125;&#125; 接口实现 12345interface Demo&#123; void method1(); void method2(); //不可以被实现&#125; 抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。 对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。 设计层次 抽象层次不同 抽象类是对类抽象，而接口是对行为抽象。抽象类是对整个类整体抽象，包括属性、行为。但是接口只是对局部（行为）进行抽象。 跨域不同 抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类（即使没有相似特点）。我们知道抽象类是从子类发现公共部分，然后泛化成抽象类，子类继承该父类即可。但是接口不同，实现它的子类可以没有任何关系。例如：猫、狗可以抽象成一个动物类，具备叫的方法。鸟、飞机可以实现 fly 接口，但是鸟和飞机不能抽象成一个抽象类吧！ 设计层次不同 对于抽象类，它是自上而下来设计的，我们要先知道子类才能抽象出父类。而接口则不同，它根本不需要知道子类的存在，只需要定制一个「规范」即可。例如，我们只有一个猫类在这，你抽象出一个动物类，就有点过了。但如果有一个猫类、一个狗类，这时候你可以抽象出他们的共同点成一个动物类！ 对于接口，比如飞这个接口，我们根本不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。 所以说：抽象类是自上而下设计的，而接口是自下而上设计的 。 参考文章 知乎回答 博客园回答]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手机万才项目总结]]></title>
      <url>%2F2017%2F04%2F11%2F%E6%89%8B%E6%9C%BA%E4%B8%87%E6%89%8D%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[前言经过寒假的筹备，从开学（2017.2.19）正式编码，到校赛正式答辩（2017.4.5），大概 1 个半月的时间，同赵俊文一同开发了我的第一个完整的项目——「手机万才」。在完成这个项目的过程中，无论是技术上还是管理上，都遇到了不少问题，幸运的是，最终都克服了。虽然最终答辩的时候，发挥的不是很理想，但还是获得了三等奖（还是可以接受的）。现在做个小小的总结吧，为自己 1 个半月的忙碌做个交待，也为今后少走弯路。 技术代码规范在之前写小 demo 的时候，没有觉得代码规范的重要性，当项目稍微大了点的时候，必须强迫自己做好代码规范，不仅方便自己编码，也方便别人合作。 目录结构 ​ 可以粗略地按照功能分类 命名规范类和接口： 类名必须使用驼峰 命名规则 eg : BookReadPlanAdd 方法命名： 方法名是一个动词，采用大小写混合的方式，第一个单词首字母小写，其后单词的首字母大写 eg : public void getBookName(); 变量命名： 临时变量一般取名 i，j，k，m，n，一般用于整型；c，d，e，一般用于字符型。 ​ 变量命名也必须采用驼峰规则，但是首字母必须小写。eg : bookName 成员变量命名： 同变量命名，但不要在私有变量前添加「m」字样。 常量命名： 类常量的声明全部大写，单词间用下划线隔开。 eg ： static final int MIN_WIDTH = 4; layout 命名： 全部单词小写，单词间以下划线分割，并且使用名词或名词词组 来命名 id命名： 全部单词小写，单词间以下划线分割，并且使用名词词组，并且要求能够通过 id 直接理解当前组件要实现的功能。 eg ； @+id/book_name_show 资源命名： layout 中所使用的所有资源（drawable，style 等）命名必须以全部单词小写，以下划线分割。 规约方法： 一个方法最好不要超过 15 行，如果方法太长，说明当前方法业务逻辑已经非常复杂，最好进行拆分，确保一个方法只做一件事。 参数和返回值： 一个方法的参数尽量不要超过 4 个。 神秘的数： 代码中不允许出现单独的数字、字符，如果必须出现，则必须将它们按照含义封装为静态常量。 访问控制： 如果没有足够理由，不要把实例或者类变量声明为公有。 编码技巧 定制基类可以自己定制各种基类 BaseActivity 、BaseFragment、BaseAdapter，可以将常用的方法等封装到里面，如：界面跳转、Toast、抽象初始化方法 init() 等。 如果使用 ButterKnife ，则必须在基类中定义抽象的setMyContentView() ，让 ButtertKnife 与视图绑定，否则在子类中会出现控件绑定不成功的情况，具体代码如下： 12345678910private void initLayout() &#123; setMyContentView(); ButterKnife.bind(this); &#125; /** * 由子类进行重写 * 在该方法中，子类指定布局文件 */ public abstract void setMyContentView(); 子类中实现该抽象方法 1234@Override public void setMyContentView() &#123; setContentView(R.layout.activity_login); &#125; 写了这个后，onCreate() 方法便不用再写了，具体的初始化操作，可以放在 init() 方法中，理清代码逻辑。 资源调用图片： 通常的图片放入drawable 文件夹中，在不做屏幕适配的情况下，建议放入xhdpi或xxhdpi文件夹中，mipmap 文件夹中通常放图标。 颜色资源： colorPrimary 、colorPrimaryDark 、colorAccent 需要指定，很多地方可以直接配置。 字符串与尺寸资源： title 、subtitle 、body 、caption 、largebody 等都可以指定。 优秀的第三方库 筛选菜单库： compile &#39;com.github.dongjunkun:DropDownMenu:1.0.3&#39; 坑 需要在 values 文件夹下新建interger.xml 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;integer name="drop_down_menu_animation_duration"&gt;200&lt;/integer&gt;&lt;/resources&gt; 黄油刀注解： compile files(&#39;libs/butterknife-7.0.1.jar&#39;) 告别findViewById() 图片加载库： compile files(&#39;libs/universal-image-loader-1.9.2_sources.jar&#39;) 广告栏： compile &#39;cn.bingoogolapple:bga-banner:2.1.7@aar&#39; 解析json： compile files(&#39;libs/gson-2.6.2.jar&#39;) 底部导航栏： compile &#39;com.ashokvarma.android:bottom-navigation-bar:1.2.0&#39; 圆形头像： compile &#39;de.hdodenhof:circleimageview:2.1.0&#39; 可以弹出菜单的FAB： 1234/***添加rfab需要添加三个依赖***/ compile &apos;com.github.wangjiegulu:AndroidBucket:1.0.4&apos; compile &apos;com.github.wangjiegulu:AndroidInject:1.0.6&apos; compile &apos;com.github.wangjiegulu:RapidFloatingActionButton:1.0.3&apos; 强劲的后端支持 BmobBmob 官网 查询官方文档，可以方便的实现很多功能，对于移动开发提供了很多便利。 最美的 Material Design 设计作为 Android 开发者，当然是要推崇 MD 设计了，大量运用 MD 组件，采用 MD 图标，使用 MD 推荐的颜色。Material Design 官网 管理技术方面很多都可以通过搜索引擎来解决，但是管理这东西，真的不容易。想起我们的视频在答辩前10分钟才完成，文档写的很简陋，ppt不符合服务外包比赛的方向，这都是导致我们成绩不理想的原因。以后再参加类似比赛，如何能在15分钟左右时间内尽可能的展现出「创新点」、「比赛要求」、「技术运用」等干货才是最重要的，而不是说「产品历程」等无关痛痒的东西。 后记总之，经过这次项目以及担任 leader 的经历，自己的技术得到了提高，管理方面也有了自己的一点见解。继续前行吧！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown 语法学习]]></title>
      <url>%2F2017%2F04%2F09%2FMarkdown-%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[标题在 Markdown 中，你只需要在文本前面加上# ，通过设置# 的个数，来确定标题的级别 注意： # 与标题之间有一个空格 列表 文本1 文本2 文本3 只需要在文本前面加上- 、+ 、* 注意： - 与文本之间有一个空格 有序列表 文本1 文本2 文本3 只需要在文本前面加上1. 注意： 1. 与文本之间有一个空格 插入链接简书 格式为：[文本](链接) 插入图片格式为：![文本](图片链接) 插入下划线格式为：--- 引用 做自己喜欢的事 在文字前面加&gt; 粗体和斜体斜体 ：在文本前后各加一个* ，如：*文本* 粗体 ：在文本前后各加两个* ，如：**文本** 代码引用 单行代码引用：hello world 使用 ` 将语句包起来 多行代码引用： 123public static void main(String[] args)&#123; System.out.println("hello world");&#125; 使用 ``` 将语句包起来 博客中插入图片插入图片 暂时先不采用「图床」的方式，直接加载本地图片解决吧 结语这里只是暂时列出了几种最常用的 Markdown 语法，有一些高级语法，暂时还用不到，就先不写，等用到时再加以补充。以后写博客使用 Markdown + stormzhang 的排版标准来写，坚持下去，提高自己的写作能力。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub + Hexo 搭建个人博客]]></title>
      <url>%2F2017%2F04%2F08%2FGithub-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[前言寒假的时候就想搭个博客玩了，一直没有具体实施。现在终于花费了 1 天的时间撘成了，心情还是有点小激动。以后就会将一些技术方面的文章、学习心得放到这里，这里就会成为我的「技术小天地」，希望自己技术能力得到提高，写作能力也能有长足的进步吧。 步骤概览 环境配置 Hexo 的安装、部署 NexT 主题的配置 绑定域名（可选） 环境配置 Git 的安装与配置 Git 的下载地址 Node.js 的安装 Node.js 的下载地址 注册 GitHub 账号 GitHub 的官网 配置 SSH key Linux 与 Mac 都是默认安装了 SSH ，而 Windows 系统安装了 Git Bash 应该也是带了 SSH 的。大家可以在终端（win 下在 Git Bash 里）输入 ssh ,如果出现以下提示证明你本机已经安装 SSH ，否则请自行安装 紧接着输入 ssh-keygen -t rsa ，指定 rsa 算法生成算法密钥，接着连续三个回车键（不需 要输入密码），然后会生成两个文件 id_ras 和 id_ras.pub ，而 id_ras 是密钥，id_ras.pub 是公钥。这两个文件默认分别在如下目录下生成： /c/Documents and Settings/username/.ssh 接着就是在 GitHub 上添加 SSH key ，相信大家会有办法的。 SSH key 添加成功后，输入ssh -T git@github.com 进行测试，如果出现以下提示证明添加成功了。 成功之后，我们就可以向 GitHub 提交代码，也可以部署我们的博客到 GitHub Page 上了。 搭建 GitHub Page 登录 GitHub 后，新建一个仓库。仓库名为 username.github.io username 为你自己的用户名，这是特殊的词法约定。 注意 ：仓库中必须有文件才可以访问，你可以先添加一个Readme文件 Hexo 的安装、部署Hexo 是一个简单、快速、强大的静态博客生成工具，支持 Markdown 格式。 这里是官方介绍 在任意一个盘符，新建「hexo」文件夹，比如我在D盘新建，作为 博客的文件夹。 打开 Git Bash ，运行 Hexo 安装命令 npm install -g hexo ps: 这里 npm(node package management) 在安装 Node.js 的时候已经默认安装 进入 hexo 目录下 cd D:/hexo 运行以下命令，Hexo 随后将自动在目标文件夹中国建立网站所需要的所有文件。 hexo init 搭建一个本地博客 hexo g 生成博客 hexo s 启动本地服务预览 hexo s -g 两者也可以合并起来 hexo deploy 可以将本地博客上传至 Git 仓库 然后在浏览器中输入「localhost:4000」即可预览已生成的博客 新建文章并部署到 Github hexo new 「文档名」 在 source/_post 目录下生成对应的 .md 文档 hexo d -g 即可以生成文档并将文档部署到 Github NexT 主题的安装、配置原有的主题是landscape ，但是不一定符合所有人的喜好，可以更换主题，让自己的博客更具个性化，这里我选用了简洁大方的 NexT 主题，来打造我的博客，当然也有其他好看的主题，大家可以自行安装、配置。 一些 Hexo 博客主题推荐 NexT 主题安装配置 NexT 主题官方配置说明 注意： 其实按着官方配置说明没什么大问题，但又几个坑需要注意： _config 文件中修改的时候，注意加空格 写 Markdown 文件的时候，tag 、categories 的时候也一定要加空格，或者写成如下形式： 12345tag:- Java- Androidcategories:- Tech 设置logo 主题配置文件中 favicon: images/logo.png 添加评论 添加评论的话，不要用多说（快要关闭了），改用 disqus 添加阅读量 阅读量 设置 RSS 功能，需要下载插件 设置RSS 绑定域名（可选）作为一个技术博客，怎么能甘心依附于一个二级域名呢？去阿里云上买一个域名，添加解析，然后在自己的本地文件中也添加好解析，便大功告成，具体步骤可以参考这篇文章。 Hexo 博客绑定域名 后记大致功能就这样，只要善用搜索引擎，没有什么问题解决不了的。坚持下去，记录自己学习的点滴。 ###]]></content>
    </entry>

    
  
  
</search>
