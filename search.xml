<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android 回调机制理解]]></title>
      <url>%2F2017%2F04%2F16%2FAndroid-%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[前言经常听什么「回调」啊，Android 框架里什么生命周期啊，各种监听事件啊，直白一点，各种带「on」的方法，都是「回调方法」，一直想了解，但是一直没理解清楚。现在参考了网上的一些例子，梳理一下。 PS：首先要清楚 Java 中接口的相关概念，其次要有一点「事件分发机制」的了解（暂时还没弄清楚，以后写博客总结）。 概念A 类中定义一个方法，这个方法中用到一个接口变量和该接口中的方法，但这个接口中的抽象方法需要 B 类去实现，B类实现该方法后，它本身不会调用该方法，而是传递给 A 类，供 A 类调用，这种机制称为「回调」。 实战下面我们拿 button 的点击事件来分析模拟： 首先，在 View 类中，找到interface OnClickListener ： 123public interface OnClickListener()&#123; void onClick(View var);&#125; 这是定义的接口，然后还有对应的接口变量：public OnClickListener mOnClickListener 。 其次，在 View 类中我们能找到 setOnClickListener(OnClickListener l) 方法： 123456public void setOnClickListener(OnClickListener l)&#123; if(!isClickable())&#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l;&#125; 该方法中，将 OnClickListener l 赋值给了 成员变量 mOnClickListener。 我们继续往下找，找到在 performClick() 方法中，执行了我们的onClick() 方法。 12345678910public boolean performClick() &#123; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); return true; &#125; return false; &#125; 这就是概念中所说的，A 类中接口变量调用抽象方法的方法，也就是 B 类回调 A 类的方法。 在某一个 Activity 中，实现 button 的点击事件。 123456button.setOnClickListener(new OnClickListener&#123; @Override public void onClick(View view)&#123; //做具体的操作 &#125;&#125;); 这里就将一个接口的实现类作为参数传入 View 类中的 setOnClickListener() 方法中，从而为 View 类中的 成员变量 mOnCLickLisetener 赋值。 接着就是在父类中，也就是 View 类中执行 onClick() 方法，为什么会在父类中执行该方法呢？这就要说到 Android 中的另一个重要的机制——「事件分发机制」。当我们手指触摸到手机屏幕，就一定会执行dispatchTouchEvent(MotionEvent event) 方法。（此处省略10000字） 简单点说就是：通过事件分发机制，最终调用了performClick() 方法，从而执行了onClick() 方法。 123if(!post(mPerformClick))&#123; performClick();&#125; 为什么要回调这里体现了Java 中的「万事万物皆为对象」的理念，我们需要将普通物体的特性抽象出来，共性之中又有特性，每种特性交由不同的情况处理，通过接口暴露的方法可以减少很多重复，代码更加优雅。 例如：Button 和 TextView 都继承于 View，在做点击事件时，点击的具体逻辑是不同的。我点Button 可能弹出一个 toast，而点击 TextView 弹出一个 Notifaction，这时候回调的好处就体现出来了，因为 Android 对外暴露了 onClickListener() 接口，里面要去具体实现 onClick() 方法，就在这我们就可以随意定制了。而 View 的话，不管你如何实现，它只负责调用 onClick() 方法。 这样，代码更加简洁，逻辑也更加清晰，也算多态的一种实现吧。 参考文章Android 中的回调函数机制解析 android 中的回调 Android 回调函数机制那点事]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 接口深入理解]]></title>
      <url>%2F2017%2F04%2F16%2FJava-%E6%8E%A5%E5%8F%A3%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[直观印象 抽象方法的集合，是一种对行为的抽象 是一种程序之间的一种「协议」或者「规范」 实现「多态」的一种手段 注意事项 接口本身不是「类」，我们不能实例化一个接口，如 new Runnable() 肯定是错误的，我们只能 new 它的实现类。 interface 的所有方法访问权限自动被声明public 及 abstract 。确切的说，只能声明为public 和 abstract 。 接口中可以定义「成员变量」，或者说是不可变的常量，因为接口中的「成员变量」会自动变为public static final 。可以通过实现类名直接访问ImplementClass.name 。 接口中不存在实现的方法。 实现接口的非抽象类 必须要实现该接口的所有方法。抽象类可以不用实现。 不能使用new 操作符来实例化一个接口，但可以声明一个接口变量，该变量必须引用一个实现该接口的实现类。 实现多接口的时候一定要避免方法名的重复。 为什么要使用接口 接口是一种规范，一种「招牌」，便于查看，便于维护和拓展 知乎上详细的例子 接口就是个招牌。 比如说你今年放假出去杭州旅游，玩了一上午，你也有点饿了，突然看到前面有个店子，上面挂着KFC，然后你就知道今天中饭有着落了。 KFC就是接口，我们看到了这个接口，就知道这个店会卖炸鸡腿（实现接口）。 那么为神马我们要去定义一个接口涅，这个店可以直接卖炸鸡腿啊（直接写实现方法），是的，这个店可以直接卖炸鸡腿，但没有挂KFC的招牌，我们就不能直接简单粗暴的冲进去叫服务员给两个炸鸡腿了。 要么，我们就要进去问，你这里卖不卖炸鸡腿啊，卖不卖汉堡啊，卖不卖圣代啊（这就是反射）。很显然，这样一家家的问实在是非常麻烦（反射性能很差）。 要么，我们就要记住，中山路108号卖炸鸡，黄山路45号卖炸鸡（硬编码），很显然这样我们要记住的很多很多东西（代码量剧增），而且，如果有新的店卖炸鸡腿，我们也不可能知道（不利于扩展）。 接口实现多态 知乎上详细的例子 接口的作用对于很多新手来说很不容易理解，我给大家举个例子。接口只是一个规范，所以里面的方法都是空的。假如我开了一个宠物粮店，声明所有宠物都可以来我这里买粮食，这就相当于一个接口， public interface PetRestaurant { public void buy();} 当一只狗看到了，知道自己是宠物，所以它去实现这个接口public class DogPet implements PetRestaurant { @Override public void buy() { System.out.println(“我是狗，我要买狗粮”); }}当一只猫看到了，知道自己也是宠物，所以也去实现这个接口public class CatPet implements PetRestaurant { @Override public void buy() { System.out.println(“我是猫，我要买猫粮”); } }当狗和猫来我的店之前，我是不知道他们到底是什么，但是当他们来到我的店，我就知道一个要猫粮食，一个要狗粮食。因为他们都实现了 我这个接口，都可以买。下面这个类相当于一个接待顾客的类，即店小二，他接待所有实现了我这个宠物店接口的动物，传进来一个PetRestaurant 类型的宠物，注意，这个PetRestaurant 是接口public class test { public void buy(PetRestaurant pet) { pet.buy(); }} 好了，这个时候我这个老板出现了，我可以给他们卖粮食了，相当于测试类public class Tests { public static void main(String[] args) { PetRestaurant dog = new DogPet(); //实例化一个狗，相当于把狗顾客实例化 PetRestaurant cat = new CatPet();//实例化一个猫，相当于把猫顾客实例化 test t = new test(); //实例化一个店小二 t.buy(cat); //把猫交给店小二 t.buy(dog); //把狗交给店小二 } }这样运行的结果就是我是猫，我要买猫粮我是狗，我要买狗粮 你知道吗，整个过程我这个店主其实根本不知道来的到底是猫是狗还是其他什么，我只要有一个店小二，把这些来的不知什么动物都全部交给店小二，店小二就知道怎么去卖了，因为这些狗啊猫啊都实现了我这个宠物店的接口，而店小二就负责接待所有实现了我这个接口的动物。这就有一个好处，假如明天来了一头小猪，只要它实现了我这个接口，我只管交给店小二处理就OK了，我这个店小二根本不需要变化，我这个店主也只需要实例化一下这个动物就OK你想，假如没有接口，会怎么办，来一个猫，我要去创造一个猫，还要实例化，来一只狗，我要创建一只狗，同样要实例化，还要配备专门的店小二去接待，就会相当麻烦。 接口和抽象类的区别 语法层次 抽象类实现 1234567public abstract class Demo&#123; abstract void method1(); void method2()&#123; // 可以实现 &#125;&#125; 接口实现 12345interface Demo&#123; void method1(); void method2(); //不可以被实现&#125; 抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。 对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。 设计层次 抽象层次不同 抽象类是对类抽象，而接口是对行为抽象。抽象类是对整个类整体抽象，包括属性、行为。但是接口只是对局部（行为）进行抽象。 跨域不同 抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类（即使没有相似特点）。我们知道抽象类是从子类发现公共部分，然后泛化成抽象类，子类继承该父类即可。但是接口不同，实现它的子类可以没有任何关系。例如：猫、狗可以抽象成一个动物类，具备叫的方法。鸟、飞机可以实现 fly 接口，但是鸟和飞机不能抽象成一个抽象类吧！ 设计层次不同 对于抽象类，它是自上而下来设计的，我们要先知道子类才能抽象出父类。而接口则不同，它根本不需要知道子类的存在，只需要定制一个「规范」即可。例如，我们只有一个猫类在这，你抽象出一个动物类，就有点过了。但如果有一个猫类、一个狗类，这时候你可以抽象出他们的共同点成一个动物类！ 对于接口，比如飞这个接口，我们根本不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。 所以说：抽象类是自上而下设计的，而接口是自下而上设计的 。 参考文章 知乎回答 博客园回答]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手机万才项目总结]]></title>
      <url>%2F2017%2F04%2F11%2F%E6%89%8B%E6%9C%BA%E4%B8%87%E6%89%8D%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[前言经过寒假的筹备，从开学（2017.2.19）正式编码，到校赛正式答辩（2017.4.5），大概 1 个半月的时间，同赵俊文一同开发了我的第一个完整的项目——「手机万才」。在完成这个项目的过程中，无论是技术上还是管理上，都遇到了不少问题，幸运的是，最终都克服了。虽然最终答辩的时候，发挥的不是很理想，但还是获得了三等奖（还是可以接受的）。现在做个小小的总结吧，为自己 1 个半月的忙碌做个交待，也为今后少走弯路。 技术代码规范在之前写小 demo 的时候，没有觉得代码规范的重要性，当项目稍微大了点的时候，必须强迫自己做好代码规范，不仅方便自己编码，也方便别人合作。 目录结构 ​ 可以粗略地按照功能分类 命名规范类和接口： 类名必须使用驼峰 命名规则 eg : BookReadPlanAdd 方法命名： 方法名是一个动词，采用大小写混合的方式，第一个单词首字母小写，其后单词的首字母大写 eg : public void getBookName(); 变量命名： 临时变量一般取名 i，j，k，m，n，一般用于整型；c，d，e，一般用于字符型。 ​ 变量命名也必须采用驼峰规则，但是首字母必须小写。eg : bookName 成员变量命名： 同变量命名，但不要在私有变量前添加「m」字样。 常量命名： 类常量的声明全部大写，单词间用下划线隔开。 eg ： static final int MIN_WIDTH = 4; layout 命名： 全部单词小写，单词间以下划线分割，并且使用名词或名词词组 来命名 id命名： 全部单词小写，单词间以下划线分割，并且使用名词词组，并且要求能够通过 id 直接理解当前组件要实现的功能。 eg ； @+id/book_name_show 资源命名： layout 中所使用的所有资源（drawable，style 等）命名必须以全部单词小写，以下划线分割。 规约方法： 一个方法最好不要超过 15 行，如果方法太长，说明当前方法业务逻辑已经非常复杂，最好进行拆分，确保一个方法只做一件事。 参数和返回值： 一个方法的参数尽量不要超过 4 个。 神秘的数： 代码中不允许出现单独的数字、字符，如果必须出现，则必须将它们按照含义封装为静态常量。 访问控制： 如果没有足够理由，不要把实例或者类变量声明为公有。 编码技巧 定制基类可以自己定制各种基类 BaseActivity 、BaseFragment、BaseAdapter，可以将常用的方法等封装到里面，如：界面跳转、Toast、抽象初始化方法 init() 等。 如果使用 ButterKnife ，则必须在基类中定义抽象的setMyContentView() ，让 ButtertKnife 与视图绑定，否则在子类中会出现控件绑定不成功的情况，具体代码如下： 12345678910private void initLayout() &#123; setMyContentView(); ButterKnife.bind(this); &#125; /** * 由子类进行重写 * 在该方法中，子类指定布局文件 */ public abstract void setMyContentView(); 子类中实现该抽象方法 1234@Override public void setMyContentView() &#123; setContentView(R.layout.activity_login); &#125; 写了这个后，onCreate() 方法便不用再写了，具体的初始化操作，可以放在 init() 方法中，理清代码逻辑。 资源调用图片： 通常的图片放入drawable 文件夹中，在不做屏幕适配的情况下，建议放入xhdpi或xxhdpi文件夹中，mipmap 文件夹中通常放图标。 颜色资源： colorPrimary 、colorPrimaryDark 、colorAccent 需要指定，很多地方可以直接配置。 字符串与尺寸资源： title 、subtitle 、body 、caption 、largebody 等都可以指定。 优秀的第三方库 筛选菜单库： compile &#39;com.github.dongjunkun:DropDownMenu:1.0.3&#39; 坑 需要在 values 文件夹下新建interger.xml 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;integer name="drop_down_menu_animation_duration"&gt;200&lt;/integer&gt;&lt;/resources&gt; 黄油刀注解： compile files(&#39;libs/butterknife-7.0.1.jar&#39;) 告别findViewById() 图片加载库： compile files(&#39;libs/universal-image-loader-1.9.2_sources.jar&#39;) 广告栏： compile &#39;cn.bingoogolapple:bga-banner:2.1.7@aar&#39; 解析json： compile files(&#39;libs/gson-2.6.2.jar&#39;) 底部导航栏： compile &#39;com.ashokvarma.android:bottom-navigation-bar:1.2.0&#39; 圆形头像： compile &#39;de.hdodenhof:circleimageview:2.1.0&#39; 可以弹出菜单的FAB： 1234/***添加rfab需要添加三个依赖***/ compile &apos;com.github.wangjiegulu:AndroidBucket:1.0.4&apos; compile &apos;com.github.wangjiegulu:AndroidInject:1.0.6&apos; compile &apos;com.github.wangjiegulu:RapidFloatingActionButton:1.0.3&apos; 强劲的后端支持 BmobBmob 官网 查询官方文档，可以方便的实现很多功能，对于移动开发提供了很多便利。 最美的 Material Design 设计作为 Android 开发者，当然是要推崇 MD 设计了，大量运用 MD 组件，采用 MD 图标，使用 MD 推荐的颜色。Material Design 官网 管理技术方面很多都可以通过搜索引擎来解决，但是管理这东西，真的不容易。想起我们的视频在答辩前10分钟才完成，文档写的很简陋，ppt不符合服务外包比赛的方向，这都是导致我们成绩不理想的原因。以后再参加类似比赛，如何能在15分钟左右时间内尽可能的展现出「创新点」、「比赛要求」、「技术运用」等干货才是最重要的，而不是说「产品历程」等无关痛痒的东西。 后记总之，经过这次项目以及担任 leader 的经历，自己的技术得到了提高，管理方面也有了自己的一点见解。继续前行吧！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown 语法学习]]></title>
      <url>%2F2017%2F04%2F09%2FMarkdown-%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[标题在 Markdown 中，你只需要在文本前面加上# ，通过设置# 的个数，来确定标题的级别 注意： # 与标题之间有一个空格 列表 文本1 文本2 文本3 只需要在文本前面加上- 、+ 、* 注意： - 与文本之间有一个空格 有序列表 文本1 文本2 文本3 只需要在文本前面加上1. 注意： 1. 与文本之间有一个空格 插入链接简书 格式为：[文本](链接) 插入图片格式为：![文本](图片链接) 插入下划线格式为：--- 引用 做自己喜欢的事 在文字前面加&gt; 粗体和斜体斜体 ：在文本前后各加一个* ，如：*文本* 粗体 ：在文本前后各加两个* ，如：**文本** 代码引用 单行代码引用：hello world 使用 ` 将语句包起来 多行代码引用： 123public static void main(String[] args)&#123; System.out.println("hello world");&#125; 使用 ``` 将语句包起来 博客中插入图片插入图片 暂时先不采用「图床」的方式，直接加载本地图片解决吧 结语这里只是暂时列出了几种最常用的 Markdown 语法，有一些高级语法，暂时还用不到，就先不写，等用到时再加以补充。以后写博客使用 Markdown + stormzhang 的排版标准来写，坚持下去，提高自己的写作能力。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub + Hexo 搭建个人博客]]></title>
      <url>%2F2017%2F04%2F08%2FGithub-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[前言寒假的时候就想搭个博客玩了，一直没有具体实施。现在终于花费了 1 天的时间撘成了，心情还是有点小激动。以后就会将一些技术方面的文章、学习心得放到这里，这里就会成为我的「技术小天地」，希望自己技术能力得到提高，写作能力也能有长足的进步吧。 步骤概览 环境配置 Hexo 的安装、部署 NexT 主题的配置 绑定域名（可选） 环境配置 Git 的安装与配置 Git 的下载地址 Node.js 的安装 Node.js 的下载地址 注册 GitHub 账号 GitHub 的官网 配置 SSH key Linux 与 Mac都是默认安装了 SSH ，而 Windows 系统安装了 Git Bash 应该也是带了 SSH 的。大家可以在终端（win 下在 Git Bash 里）输入 ssh ,如果出现以下提示证明你本机已经安装 SSH ，否则请自行安装 紧接着输入 ssh-keygen -t rsa ，指定 rsa 算法生成算法密钥，接着连续三个回车键（不需 要输入密码），然后会生成两个文件 id_ras 和 id_ras.pub ，而 id_ras 是密钥，id_ras.pub 是公钥。这两个文件默认分别在如下目录下生成： /c/Documents and Settings/username/.ssh 接着就是在 GitHub 上添加 SSH key ，相信大家会有办法的。 SSH key 添加成功后，输入ssh -T git@github.com 进行测试，如果出现以下提示证明添加成功了。 成功之后，我们就可以向 GitHub 提交代码，也可以部署我们的博客到 GitHub Page 上了。 搭建 GitHub Page 登录 GitHub 后，新建一个仓库。仓库名为 username.github.io username 为你自己的用户名，这是特殊的词法约定。 注意 ：仓库中必须有文件才可以访问，你可以先添加一个Readme文件 Hexo 的安装、部署Hexo 是一个简单、快速、强大的静态博客生成工具，支持 Markdown 格式。 这里是官方介绍 在任意一个盘符，新建「hexo」文件夹，比如我在D盘新建，作为 博客的文件夹。 打开 Git Bash ，运行 Hexo 安装命令 npm install -g hexo ps: 这里 npm(node package management) 在安装 Node.js 的时候已经默认安装 进入 hexo 目录下 cd D:/hexo 运行以下命令，Hexo 随后将自动在目标文件夹中国建立网站所需要的所有文件。 hexo init 搭建一个本地博客 hexo g 生成博客 hexo s 启动本地服务预览 hexo s -g 两者也可以合并起来 然后在浏览器中输入「localhost:4000」即可预览已生成的博客 NexT 主题的安装、配置原有的主题是landscape ，但是不一定符合所有人的喜好，可以更换主题，让自己的博客更具个性化，这里我选用了简洁大方的 NexT 主题，来打造我的博客，当然也有其他好看的主题，大家可以自行安装、配置。 一些 Hexo 博客主题推荐 NexT 主题安装配置 NexT 主题官方配置说明 注意： 其实按着官方配置说明没什么大问题，但又几个坑需要注意： _config 文件中修改的时候，注意加空格 写 Markdown 文件的时候，tag 、categories 的时候也一定要加空格，或者写成如下形式： 12345tag:- Java- Androidcategories:- Tech 设置logo 主题配置文件中 favicon: images/logo.png 添加评论 添加评论的话，不要用多说（快要关闭了），改用 disqus 添加阅读量 阅读量 设置 RSS 功能，需要下载插件 设置RSS 绑定域名（可选）作为一个技术博客，怎么能甘心依附于一个二级域名呢？去阿里云上买一个域名，添加解析，然后在自己的本地文件中也添加好解析，便大功告成，具体步骤可以参考这篇文章。 Hexo 博客绑定域名 后记大致功能就这样，只要善用搜索引擎，没有什么问题解决不了的。坚持下去，记录自己学习的点滴。 ###]]></content>
    </entry>

    
  
  
</search>
