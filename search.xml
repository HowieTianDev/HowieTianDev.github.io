<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[云南之行游记]]></title>
      <url>%2F2019%2F06%2F24%2F%E4%BA%91%E5%8D%97%E4%B9%8B%E8%A1%8C%E6%B8%B8%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[云南之行游记三个穷学生，云南昆眀-大理-丽江毕业旅行，时长为9天8晚，由于是在淡季，花费不多，人均3400元左右。旅行中主要使用了智行火车票+大众点评+百度地图。整个旅行超级开心，拍了好多照片，风景美丽，住的、吃的都很好，完美的毕业旅行，给大学生涯拉下了帷幕。 前言搞定了毕设，胶装好材料、刻录好光盘，上交老师。学校的事情正式结束了。终于可以进行毕业旅行，最开始还想着想去西藏，奈何西藏的飞机票太过昂贵，还存在潜在的高原反应，只能搁置。还想额外加个重庆，但是为了行程安排简单，还是放弃了。最终选择了云南作为毕业旅行的目的地，虽然是高原，但是基本没什么高反，并且旅游业发达，行程也好规划。事实是正确的，过长的旅行也会让人疲惫而且玩得可能不尽兴，7天左右是最好的。 Day1:杭州-昆明：我们是晚上到的昆明长水机场，然后坐地铁到达了提前预定好的民宿，位于火车站附近，这样安排，主要是为了第二天还要做动车前往大理。昆明不是一个传统的旅游城市，更像一个传统的现代城市，一般作为旅游中转站。晚上的昆明还是很凉爽的，比起杭州的闷热不知道好了多少。安排好住宿后，去楼下吃了一碗7块的饵丝，感觉像炒饼一样，就是很粘牙，一般般吧，休息，第二天随便逛一下昆明。 Day2：上午：在大众点评上去看到一家评分很高的米线店，老滇过桥米线。就去尝试了一下，哇，原来过桥米线是这么吃的，配菜和米线分开，整的和满汉全席差不多，反正视觉冲击力还是很强的。味道也还不错，值得去尝试一下。 由于不想跑太远，我们就骑车去了附近的翠湖公园和云南大学，还有西南联大遗址。翠湖公园的荷花开得很漂亮，一些建筑也挺好看的。云大一看就是很有历史年代感的学校，整体风格也有特色。西南联大遗址是在云南师范大学校内，里面有一个121事件的博物馆，能学到一些历史知识，虽然我现在都快忘记了。 中间发生了一个小插曲，由于我们的行李放在了民宿里，但是过了12点，房间密码改掉了，最终联系客服打开房间拿到了行李。 下午：昆明-大理，坐动车前往大理，到达大理后，天有不测风云，突然下了大雨，我们一群人，打着伞在车站等8路车，准备好的防雨鞋套放在行李箱里，唯一一次下雨，却没有拿出来用，真是失误。 到了8路车终点站，雨也停了，云那么低，压在苍山头上，真的超级好看，超级震撼。感觉这才是大自然的馈赠啊。殊不知，这才是美丽景色的开端而已。安排好住宿，晚上去大理古城转了一下，去醉香居吃了一顿家常菜，确实味道不错，价格也实惠，不过得需要买美团上的套餐。好像所有的古城都差不多，都是商业化很严重，各种卖东西的，但是也有所特色吧，和我们家乡的平遥古城也还是不一样的。 Day3:大理旅行第一天，泰舒服客栈老板给我们详细讲了游玩的攻略，避免了报团，还是很棒的。所以，我们买了苍山的感通索道的票，上索道上的风景还是很棒的，可以全览整个洱海。上了苍山，苍山虽然没有太过惊艳，但还是值得一去，有珍珑棋局，小瀑布，可以去观景台上看看风景。下了山，山脚下有感通寺，可以吃20元一份的斋饭自助餐，寂照庵里有很多好看的多肉，还逛了下万佛寺，万佛寺感觉没多少特点。 本来看了网上的攻略，没打算去崇圣寺三塔，只想去下三塔倒影公园，没想到两个地方都需要门票，只需要买一张门票就可以去两个地方。三塔倒影公园就是地理位置超级好，可以清楚地拍到三塔倒影的照片，超级美。接着去了附近的崇圣寺三塔公园，崇圣寺三塔公园是南方最大的佛寺了吧，被称作佛都。三塔公园就建在苍山脚下，需要不断地拾阶而上，大理的天空真的很看，蓝天白云，什么建筑都映衬着特别美。三塔寺公园很大的，后来实在没力气了，只能让同伴去大雄宝殿，我只能在椅子上歇会了。总之，三塔公园还是值得一去的，就算不体会佛学氛围，拍照也是一个好地方。 Day4：这天的主旋律就是骑电动车，环洱海！！！提前说一句，云南紫外线真的超级强烈，如果要做环洱海这种事情，一定要做好防晒！最好是把自己全身都裹起来，否则就会像我两个同伴一样，被晒伤！（幸好我穿了长袖，哈哈哈）骑着小电动车，吹着风，看着洱海，走走停停，看到好看的景色就停下来拍拍照，也是很惬意的。一路上随处可见的白色桌子、水晶球，真的感觉烂大街了，不过彩色的吉普车倒是挺有意思的。我们是从洱海西边出发，去了海舌公园，双廊，挖色，环海东路，其实洱海真正美丽的景色在东边，西边需要穿过一些村庄，还有一些不好走的路。当阳光穿过云层，射到海面上，那景色真的让人叹为观止。还有很多小众的美丽的风景等着你们发现。环洱海全程需要120公里，需要租那种带有两块锂电车的电动车才可以完成，但是由于前段时间发生了事故，可能不好租，我们也是通过客栈老板知道信息，才租到了两辆。环洱海，就是需要带着一种闲适的心情，一路走，一路看，一路拍，虽然也很累，但是这种自由感，真的是很难得。 下午6点多还车，三个人都精疲力竭，累瘫在床上。晚上吃了一顿野生菌火锅，味道还不错，有种山珍的鲜味（可能是心里作用吧），还品尝了下烤乳扇，虽然网上说的味道很奇怪，像烂红薯一样。我觉得还行，有种乳制品发酵的味道，可以接受。但我不会再吃第二串了，哈哈。 Day5：坐火车去丽江。建议大家定客栈可以预定到古城附近即可，要不古城里酒吧众多，晚上会比较吵。下午和客栈预定了第二天玉龙雪山的门票400元/人。丽江古城也有一番特色，城中小溪缓缓流淌，青石板路很有历史厚重感，虽然同样是商业化严重，而且人比大理古城多很多。去了高拉花园餐厅吃饭，老板还给了我们一张东巴象形文字的纸，写着平安吉祥，还是挺有意思的。接着去看了大水车，纳西人家等地方。作为看过大冰的作品《你坏》的人，怎么能不去大冰的小屋去看一下呢，在地图上一搜，竟然出现了连锁的店，文艺气息瞬间打破。哈哈哈，最后为了体会下丽江酒吧，去了一家叫水泊梁山的酒吧，属于清吧，每半个小时换一个歌手，还是挺有感觉的。这好像是我第一次去酒吧，又一次珍贵的体验。最搞笑的是，老板过来给我们敬酒，有的没得和我们聊天，最后让我们给5星好评，笑哭了。 Day6:为了去玉龙雪山，早上6点15，车就过来接我们。早餐吃了下丽江的靠饵块，有点像手抓饼，外皮是用米粉做的，有点软粘，里面包着土豆丝和香肠，还挺好吃的。建议大家去玉龙雪山最好跟团游，要不里面的路线很复杂，离古城还远，个人出行不方便。不过，现在大索道的票都需要抢的，每天7点开抢，很庆幸我们再包车师傅的指导下，顺利的抢到了大索道票，可以上到4680米的顶峰。上山前，会免费给你防寒服和小罐氧气，前往不要听卖氧气的危言耸听，正常小罐氧气足够用了，完全不需要大瓶浓缩的。 上午，我们去了蓝月谷，蓝月谷的水是碧蓝碧蓝的，而且摸起来冰凉冰凉的，蓝月谷由几个湖泊和几个小瀑布组成，需要乘坐电瓶车，要不步行下午爬雪山可能会体力不支。蓝月谷就像一轮明镜平静地躺在雪上脚下，特别美。 中午吃了土鸡火锅，接着就去爬玉龙雪山了。首先得乘坐大索道到达4500米左右的台子上，因为是夏天，雪没有很多，但是还是有点冷。对于从来没有见过雪山的我来说，真的很震撼，亘古屹立的冰川与我们互相对视，感受着大自然的奇迹，灰褐色的岩石彷佛在诉说着远古的传说。其实我们只需要爬100多米高，但是在爬台阶的时候确实能感受到有点喘不过气，需要爬几步，然后休息一会，氧气瓶也可以吸几口，不过完全不会高反，只要慢慢爬，没有任何问题。到了顶峰，好多人都排着队和4680石碑合影，我们就算了，自己拍了几张就ok了。玉龙雪山，真的值得一去，可能冬天的时候更好看，可惜那会我们就没有时间了。 还有个小插曲，由于是包车拼团，我们三个玩的太嗨了，让一车人等我们，还是有点小愧疚。 回到酒店，不想动了，就点了个外卖，结束了一天的玉龙雪山之行。对了，玉龙雪山入口，还有导游给我们介绍什么五色经幡，祭天，需要60块，说什么祝福随着风传递到远方，感觉有点像传销，最后还是顶住了没有买，真正的祝福永远是行动，而不只是虚无的经幡。 Day7:丽江-泸沽湖，丽江到泸沽湖没有火车，只有大巴，大概需要4-5个小时，因为路上需要休息两次，要不真的撑不住。泸沽湖在宁蒗彝族自治县，在路上可以看到金沙江，还有九曲十八弯的盘山公路。到了泸沽湖需要购买门票才能进入景区，70元/人，我们即将毕业的老油条，学生票35元/人，嘿嘿。 我们客栈订到了大洛水村，这里是泸沽湖开发最早的村落，不论住行吃饭都很方便。泸沽湖位于云南和四川边境，1/3在云南，2/3在四川凉山，属于两省共治。下午休息一会后，步行去了湖边，吹着湖风，湖水真的很清澈，还可以看到浅浅的落日，真的很惬意。在湖边的时候，有人过来和我们搭讪，说明天要不要环湖，最终选择了50元/人的环湖车，100元还可以坐猪槽船去王妃岛，看亲爱的客栈。虽然我才刚刚知道，这是一个湖南卫视的综艺节目。 Day8：早上6点10分起床，没有洗漱，就奔向湖边，看日出。泸沽湖的日出很漂亮，由火烧云，黄色的云，到太阳乍现，在云彩和湖水的映衬下分外美丽。 吃了早饭，8点左右开始环湖。真的就论风景而言，泸沽湖是整个旅程中最美的一站。只不过包车环湖就是拍照打卡，坐了猪槽船、看到了亲爱的客栈，看到了花海，去了观景台，泸源涯，达祖码头，情人滩，走婚桥，草海。整个的风景都是超级美。尤其是长达两个小时的猪槽船，一艘小船，徜徉在清澈无瑕的湖水里，真的让人特别放松，湖水达到了饮用水级别，可以直接喝，在稍微浅一点的地方可以直接看到水底的水草和岩石，这是我见过的最美的湖了，尤其是进入花海的时候，整个水天一色，白花点点，偶尔能看到野鸭，鸳鸯，有点世外桃源的感觉。划船的摩梭人小哥也很淳朴，给我们讲他们的传统民俗，包括走婚啊，爬花楼啥的，还给我们唱他自编的歌，很好听。在坐船的时候，真的每个人都有自己的生活方式，不是说大城市的生活就一定比这些摩梭人生活的好，他们其实很享受这种简单的生活，在美丽的泸沽湖旁边，神圣的格姆女神上脚下，度过自己平平淡淡的生活，也是很幸福的。幸福的生活不在于你拥有了多少，而在于心态，拥有一颗好的心态，平淡的小日子也可以过得很幸福。 Day9：收拾好行囊，坐大巴离开了泸沽湖，回到了丽江。由于同伴的手机在泸沽湖拍视频进水了，所以先陪他修了手机。然后去了下丽江古城的忠义市场，也就是一个菜市场。在这里抛去了古城里的繁华，展现出了一个真实的丽江：丰富多样的水果和蔬菜，背着背篓买菜的纳西族妇女，平易近人的价格等。我们随便找了一家店，吃了一碗小锅米线，味道还不错。门口还买了5块钱一大碗的炸洋芋，还吃了包浆豆腐，都挺好吃的。接着就坐公交车去了机场。由于飞机需要经停，时间比较久，到达杭州已经是第二天凌晨1点了。我们三就在机场待了4个小时，第二天打车回到了学校，结束了9天8晚的云南之行。 总结云南的风景真的挺多的，彩云之南名不虚传。由于地处高原，云彩看起来总是那么低，随手一拍都是大片，但是一定要注意防晒！！！大理、丽江的生活节奏也比较慢，大家都有足够的时间来体会和享受生活，不像大城市，一直加班，黑白颠倒。我最喜欢的几个景点：崇圣寺三塔、洱海、玉龙雪山、泸沽湖，真的好美，对于我这种不怎么出去玩的人来说。保持一颗良好、乐观、好奇的心态，这样生活才会有乐趣，不论是在青山绿水的大自然还是在高楼林立的大都市。 旅行已经结束，生活还在继续，带着美好的回忆，准备搬砖咯~！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2018 Android 秋招总结]]></title>
      <url>%2F2018%2F10%2F31%2FAndroid-%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[更新一波，人品爆发，收到了头条的 offer call，最后的压轴 offer 感谢自己抓住了进大厂的最后机会。 在 5~6 次笔试未通过后。头条补招，今年看来是真的缺人，直接联系了 HR，说明了自己的 offer 情况。安排了第二天的面试，一二面感觉不是很难，有个 100 层楼扔杯子的智力题，自己太傻，面试官提示了好久才想出个答案。面完之后，发现最优答案需要用动态规划？卒！第三面，也是算法题占大头，如果找出一个数组中出现次数超过一半的数字，这道题在剑指offer上出现过，但是当时看到那个 partion 算法好复杂，就没有仔细看。经过面试官的提示，终于磕磕绊绊地写出了代码。还问了我完全二叉树的深度如何计算，怎么证明？磕磕绊绊地写出了一个公式，证明真的不会。最后面试官告诉我，可以通过完全二叉树的最少节点数和最多节点数，这个范围，进行一些数学运算，可以证明出来。头条三面，虽然面的不是很顺利，但是也能在面试官的提示下，越来越接近正确答案。总之，遇到比较难的问题，不要轻易放弃，尽最大可能地去想，必要可以寻求面试官的帮助。这样才能体现出自己不畏难题，勤于思考的能力呀！ 昨天收到了猫眼的 offer，薪资啥的挺符合期望的。虽然在北京，但是对比手上的 offer，南京小米，杭州贝贝网，综合考虑还是打算去北漂好了。回想起高考的时候，嫌弃北京地铁挤，雾霾严重，最终选择了南方。毕业工作的时候还是要去北京。现在只能想着离家近一点，团队技术强，让自己成长更快一点（哈哈哈，都是给自己强行找理由）。 秋招大概从8月份多开始，大大小小的公司有投了 30 家左右。大部分公司要么是笔试没有通过，要么是投递简历后，直接没有消息。真正面试的公司差不多有 网易、cvte、贝贝网、小米、招银、华为、猫眼、海康，微医、尼禄软件。感觉自己前期没有对秋招很重视，只投了几个杭州的公司。有些公司后期投递之后什么消息都没有，像 vivo 、爱奇艺什么的估计人都招满了。所以前期还是需要做好充分的准备，不要到 10 月份再投，那时候机会就不多了。 秋招的前大半段时间是实习和笔试面试同步进行的，时不时需要晚上跑回自己租的房子那边做笔试，或者在公司接个电话面试，还是很刺激的。如果有第二次机会的话，我可能会尽早地结束实习，毕竟很多面试，笔试是需要准备的。每天快 10 点回去真的没有精力去准备。 第一个面试是网易的提前批面试，一面挂。当时实习请假一周回家了，但是在家里由于种种事情，也没有好好准备。只在高铁上准备了一天，第二天抱着侥幸的心里去面了，当时对数据结构和算法真的一点都没有准备。一面面试官问到树的时候，都蒙了，不知道怎么答。面试官看我有点蒙蔽，让我说了个冒泡排序。最后没有二面通知。不过帮我报销了从家到杭州的高铁票，哈哈哈，也值了。 第二个面试是 cvte 的电话面，电话一面虽然答的磕磕绊绊，连 service 两种启动方式都答不上来，但是还是给了视频二面的机会，视频二面，面试官问了很多性能优化的问题，当时的自己基本上没有涉及到这个方面，连内存泄漏和内存溢出都搞不清楚。最终二面挂了。 中间有段时间还在校园招聘会上投了四封简历，去了两家，微医让我去实习，考虑之后给拒绝了。尼禄软件本来是看着是一个德国企业，去了之后感觉好 low，让我看书自学，但是结果是他给我发来了拒信，反正也不去，也不在乎了。 国庆前几天提出了离职，中间有天去了浙大，参加了微策略的宣讲会和笔试，可能宣讲人说他们主要招浙大、清华、北大吧，要求太高，没有收到面试通知。不过对外企的工作时间，和各种福利真的羡慕，双非只能继续找工作。 国庆后，正式提出了实习离职。这之后，似乎运气也好起来了。先面了贝贝网，虽然等的时间有点长，但是两面的体验都还不错，技术细节没有怎么问，都是问了项目情况和实习情况。这和我室友之后去面的情况有点不一样，上来直接怼算法。第二天就去一个酒店面小米，整整面了快一天，这个运气也是比较好，和同一个面 Android 的老哥交流了一些问题，相当于提前了解了面试官要问啥。最终，小米当场面到了 HR，HR 当场给了我口头 offer，那可能是我今年最高兴的一刻，所有的就业压力都释放了。回的路上滴滴师傅怪我没有及时看到他的车，我都觉得很开心，完全不 care。这应该是我秋招最难忘的时刻了。过了两天，贝贝网 HR 来了 offer call，开心地声音都在抖。又多了一个选择。 之后又相继面了招银和华为，感觉招银不需要 Android 开发，一面面试官狂怼 Java 后端技术，Android 技术感觉是在看着事先写好的问卷来问。二面的时候，展示作品的时候，APP 出了问题，有个 sqlite 的问题，自己临场编的，估计是搬起石头打自己的脚，估计留给面试官印象不怎么好。最后还是有 HR 面，但是没有后续通知，凉了。 华为的玄学面试，真的不知道他们怎么招人的，二面面试官问我大学的主要专业课是什么，我说了一堆，就忘了说编译原理。然后面试官就给我出了道编译原理的题，一道四则运算。最后当然做不出来。至今泡在池子里。 到了10月下旬，那时候想着如果再没有其他公司 offer ，只能选择南京小米了，只是工资稍微低一点。有时候运气也很重要，之前偶尔在牛客网上内推的猫眼，最初以为猫眼是阿里系的，😂，后来知道是美团系，突然给我来了面试电话，当时记得是投的上海，但是北京电话打过来。不管了，抓住这根稻草。就这样运气比较好，自己准备也充分了些，电话三面 + HR 面。昨天顺利拿到了 offer。 总结一下，找工作真的是一个不容易的过程，充分的准备，良好的心态都必不可少。还得多投，多试，多总结经验，多刷牛客网，抓住每个来之不易的机会。你有多想找到好工作，你就得付出多少努力。越努力，越幸运，机会来的时候，才能不让它溜走。 实习也很重要，很多公司对实习还是很看重的，实际工作培养的技能，一些思想都会给自己成长很大帮助。当然如何权衡实习和找工作的时机也是很重要，像我国庆休息起来才离职，就有些晚了。 现在，工作基本上确定了，也把其余两个 offer 给拒了。可以继续看下相关的书籍，提高自己的技术，不要到时候自己去实习或者工作的时候显得很菜😂。 秋招结束，感谢努力的自己，感谢默默支持我的人。 希望大家都能拿到自己满意的 offer，考研的同学也能顺利考上！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[探索快乐]]></title>
      <url>%2F2018%2F07%2F28%2F%E6%8E%A2%E7%B4%A2%E5%BF%AB%E4%B9%90%2F</url>
      <content type="text"><![CDATA[知乎上偶尔浏览到了一篇「男生哪个瞬间你感觉最心疼？」，真的感同身受。作为一个人，从小到大，每个阶段都没有「容易」二字：学生时代要面临考试、升学的压力，工作阶段要面临工作，家庭，感情的压力。看似整个人生都充满压力，那快乐从哪里来呢？快乐是射穿漫漫黑夜的几缕曙光，是冲破冰冻荒原的点点新绿。如果生活中全部是快乐，没有一丝烦恼，没有一丝压力，长此以往，那些自认为是快乐的东西也将逐渐变为平庸。换言之，没有压力，没有忧愁就没有快乐，只有压力和忧愁的衬托快乐才显得那么珍贵，令人向往。 疲劳工作了一天，躺在舒适的大床上；久久不见的朋友，偶尔的一次小聚；一直见不到的女朋友，突然和你视频…… 以上的快乐，不是一个过程，都是一个个瞬间，转瞬即逝而令人回味。在你感到压力的时候，发现自己的生活好像还没那么糟，还有希望让自己坚持下去，还有动力支撑自己走下去。当然，更高级的快乐，莫不过于「成就感」。这里有自己成长所带来的快乐：顺利地完成某项任务，学会一项新的技能，给周围的人提供自己的帮助。都会让自己产生一种更高层次的快感，也将它称为「快乐」吧。 就像我之前看到的一篇文章说的：人这一生都在探索爱啊。往大了说，爱也是快乐。人这一生也在探索快乐啊。生活不可能时时刻刻充满快乐，如果 100% 的时间都是快乐，我会感觉这个人可能有点问题。但是如何从看似平淡艰难的生活中，发现快乐是我们需要做的。保持乐观的心态，做好自己该做的事，从长远的角度看待自己的人生。如果说人生是一块璞玉，寻找快乐就是打磨它的过程，沉浸悲苦则是摧残它。成为一个快乐的人，保持孩童的好奇心，乐于分享，我想这样生活会很有意思的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[海量数据存储复习]]></title>
      <url>%2F2018%2F06%2F27%2F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%A4%8D%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[一、搜索引擎发展史ARPAnet Google 二、搜索引擎体系结构概述数据抓取子系统，内容索引子系统，内容检索子系统，链接分析子系统 爬虫：一个自动抓取网页的程序，时效性、全面性、高效性，链式原理，递归抓取、 累积式抓取（实时性低）、增量式抓取（实时性高） 全面性：暗网、深网 高效性：系统运行效率，网络带宽消耗B&gt;S/T, robots.txt文件：User-Agent：适用哪个爬虫；Allow：允许抓取的网页对象；Disallow 内容索引子系统： why?索引？不能使用遍历的匹配方法，需要对文档的表示建立索引。为了提高检索效率，应该按照一定的规则建立索引。 倒排索引：词项term，文档：document，位置：position；根据词来找文档 构建词项列表，（分词）分词算法（基于词典的方法，基于统计的方法，基于规则的方法）倒排索引压缩，减少索引占用的磁盘空间，文档、词项编号压缩：可变长编码 正排索引：根据文档来找词 提供高效、准确的索引查询服务，层次索引结构 内容检索子系统 理解用户查询需求，相似度计算，生成结果网页列表，相关度排序 链接分析子系统 网络资源质量评估（推荐系统）PageRank、扩充文档描述内容 共性的设计理念： 用户需求驱动，强调效率的设计理念，强调可扩展性，有损优化的设计理念 三、数据抓取子系统及时、高效 尽可能多的万维网页面，建立它们之间的超链接关系 时效性、全面性、高效性 无序=》有序 全、新、块、省 网络协议 搜索引擎与网页内容提供者存在互相依存的关系，“网络协议”URL、HTTP、HTTPS User-Agent：用来表明终端程序的身份 robots:User-agent：指明适用于哪个爬虫，Disallow:禁止访问的对象 12User-agent:slurpDisallow:/ //禁止slurp 抓取所有的内容 meta标签： 123&lt;meta name="robots" content="index/noindex" follow/nofollow/&gt;// index 禁止与否拓展页面// follow 禁止与否拓展链接 Site Map:为了让网站的网页更全面被抓取 网页抓取和解析 同步抓取、异步抓取 DNS预解析 遵守协议 DOM 树 链接选取策略 抓取优先级策略：深度优先，广度优先（常用），反向链接数（受欢迎数），局部pageRank（评估网页质量，网页优先抓取），最佳优先，首先预测网页是否有用 网页更新策略：重返，更新；统一更新，个性化更新 链接去重策略：关键在于记住爬行历史，哈希表 重复与低质量页面内容检测 I-Match算法 如何实现高效率网页数据抓取？四、内容索引子系统倒排索引、正排索引、索引查询 构建词项列表： 挑战：高效、可扩展 分词-》建立词项列表 词项处理：去除频率高、语义信息少的词，倒排索引精简 中文分词：词典（机械分词法，正向、逆向、双向匹配法）、统计、理解 难点：交叉歧义，组合歧义，新词识别 评价：响应度、兼容性、准确率（正确分词数目/所有分词数目*100%）、。。。。 索引数据结构 原始数据存放。。 按文档分桶： 按词项分桶： 索引建立过程 索引压缩：霍夫曼编码 索引查询过程 性能优化：缓存服务器、时间局部性原理，HTML关键域倒排索引 中文搜索引擎特殊需求？五、内容检索子系统文本信息检索，计算文档与查询的相关度，靠哪些特征进行文档排序？ 文档信息检索模型：布尔模型（与或非高级查询，满足和不满足，集合并非序列）、向量空间模型、概率模型 内容检索子系统运行方式 tf-idf 偏好设置、竞价排名 影响搜索引擎结果排序的因素有哪些？六、链接分析子系统主要功能：扩充文档描述内容，实现页面质量评估 互联网数据特性：数量大、数据质量参差不齐、 万维网链接结构特性 连通性、拓扑结构、入度、出度，“纺锤结构” 链接结构分析算法： HITS算法，针对特定主题的文档进行链接分析计算（与主题不相关文档的噪声影响，效率问题，实时进行） PageRank算法： PageRank 与 HITS 算法的主要区别： 对网页质量的定义不同（用户浏览到网页的概率，内容权威度） 施行对象不同（整个链接结构图，某个主题的搜索结构） 运行效率不同（离线计算效率高，在线效率低） 七、搜索引擎性能评价如何全面评价搜索引擎性能？ 语料库：真实性、代表性、精确性 用少量的查询样例代表大多数查询类别 准确率：找到的是否准确 1/1 1/2 2/3 6/10 召回率：找到的是否全面 除以总的相关文档 1/6 2/6 3/6 平均准确率：Ap = 累加precision（i）/N 就算没有6个被找到，也会除以6 前Ｎ位准确率 前Ｎ位成功率]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MVP架构学习(三)之优化 MVP]]></title>
      <url>%2F2018%2F04%2F19%2FMVP%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E4%B8%89-%E4%B9%8B%E4%BC%98%E5%8C%96-MVP%2F</url>
      <content type="text"><![CDATA[前言之前，我们模仿了 Google 官方的 MVP Demo，发现这个还是太过简单：封装不够好，这样会造成正式开发的时候代码冗余程度很高；同时，对一些异常处理（空指针，内存泄漏）也不是很全面。所以，我们取其精华，优化出属于我们自己的 MVP 架构。 Base 基类的封装 BaseView 的封装和之前类似，将常用的 UI 方法写到接口中即可。 1234567891011public interface BaseView &#123; // 将 View 层同 Presenter 绑定的抽象方法 //void setPresenter(T presenter); //showToast void showToast(String msg); void showProgress(String msg); void dismissProgress(); // 跳转界面 void jumpTo(Class&lt;?&gt; clazz, boolean isFinish); void jumpTo(Intent intent, boolean isFinish);&#125; BasePresenter 的封装是一个抽象类，之前 Google 的 Demo BasePresenter 是一个接口，但是在实际使用中，考虑到一些异常处理，如 View 的空指针，内存泄漏问题等，只对行为进行抽象 的接口做不了那么多功能，所以采用抽象类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public abstract class BasePresenter&lt;T extends BaseView&gt; &#123; /** * 绑定的 view */ private Reference&lt;T&gt; view; // presenter 调用 model 开始获取数据并调用 view 中的方法初始化界面 // 调用时机是 onResume() 方法中 public abstract void start(); /** * 绑定 view，在初始化方法 onCreate() 中调用 * 设置弱引用，防止内存泄漏 * @param view */ public void attachView(T view)&#123; this.view = new WeakReference&lt;T&gt;(view); &#125; // 释放 view，防止 model 请求网络任务耗时过久，view 层由于一些特殊原因，已经销毁， // 但是由于 presenter 仍持有 view 层的引用，导致 view 层不能被 GC // 所以需要手动设置 view = null 使view 被 GC，防止内存泄漏 // 调用时机为 view 层的 onDestroy() // 将 presenter 层对 view 的引用置为空，防止 view 不能被GC，导致内存泄漏 public void detachView()&#123; if(view!=null)&#123; view.clear(); view = null; &#125; &#125; /** * 但是 view 置空后，防止出现 presenter 层 view 调用空指针 * 判断是否与View建立连接 * 每次调用业务请求的时候都要先调用方法检查是否与 View 绑定 */ public void checkViewAttached()&#123; if(view == null||view.get() == null)&#123; return; &#125; &#125; /** *获取连接的 view */ public T getView()&#123; return view.get(); &#125;&#125; 之前绑定 View 的方法是放在 Presenter 的构造方法中实现的，但这样不能同 Activity 的生命周期相关联，因为若 Model 层做了一些长时间的数据处理工作，但是 Activity 由于某种原因在数据处理没有完成的时候就异常退出，首先 model 持有 presenter 的引用，presenter 又持有 view 的接口的引用，这个 view 接口实际上就是 activity 的引用，activity 退出，但是由于 GC 引用链还是在引用着 activity，activity 不能被 GC 回收，这样 activity 就占用着内存不会释放，内存泄漏发生了，严重会导致 OOM。 解决方法： 首先实现 attachView()、detachView()，负责在 Activity 的 onCreate()、onDestroy()，绑定 view 和解绑 view，在 onDestroy() 的时候，强制 view = null，这样就可以让 Activity 顺利 GC，防止内存泄漏。 如果在内存不足的情况，系统会强制回收 Activity，这时不走 onDestroy() 方法，这样的话，presenter 仍然持有 view 的引用，导致 view 无法 GC。所以，将 view 声明为弱引用，系统在内存不足的时候，就会回收弱引用的对象，不会发生内存泄漏。 解决了内存泄漏问题，但是还可能会有View 空指针 的问题，所以在调用业务方法之前，先用 checkViewAttached() 方法检查下 View 是否空指针，增强代码的健壮性。 BaseActivity 一个抽象类，实现 BaseView 的接口，采用 BaseView 和 BasePresenter 的泛型支持，将 attachView() 和 dettachView() 直接添加到 BaseActivity 的生命周期里，减少重复代码，提出一个抽象方法，用于子类实例化对应的Presenter。当然由于使用了 ButterKnife ，所以提出一个抽象方法，用于子类返回布局 ID。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public abstract class BaseActivity&lt;T extends BaseView, V extends BasePresenter&gt; extends AppCompatActivity implements BaseView &#123; private ProgressDialog progressDialog; private V mPresenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(getContentViewId()); ButterKnife.bind(this); mPresenter = createPresenter(); if (mPresenter != null) &#123; mPresenter.attachView((T) this); &#125; init(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); if (mPresenter != null) &#123; mPresenter.detachView(); &#125; &#125; /** * 抽象方法，每个布局设置布局文件，需要子类去具体实现，下面加上ButterKnife的初始化 */ public abstract int getContentViewId(); /** * 抽象方法，创建对应的 presenter,protected 只有子类及同一个包类可以访问 */ protected abstract V createPresenter(); // 一个初始化方法 public void init() &#123; &#125; /** * 常用的几个方法 */ @Override public void showToast(String msg) &#123; if (!TextUtils.isEmpty(msg)) &#123; Toast.makeText(this, msg, Toast.LENGTH_SHORT).show(); &#125; &#125; @Override public void showProgress(String msg) &#123; progressDialog = new ProgressDialog(this); progressDialog.setTitle(msg); progressDialog.setCanceledOnTouchOutside(false); progressDialog.show(); &#125; @Override public void dismissProgress() &#123; if (progressDialog != null) &#123; progressDialog.dismiss(); &#125; &#125; @Override public void jumpTo(Class&lt;?&gt; clazz, boolean isFinish) &#123; Intent intent = new Intent(this, clazz); startActivity(intent); if (isFinish) &#123; finish(); &#125; &#125; @Override public void jumpTo(Intent intent, boolean isFinish) &#123; startActivity(intent); if (isFinish) &#123; finish(); &#125; &#125;&#125; BaseFragment 同 BaseActivity 大致相同，不再重复。 具体调用 契约类实现： 里面写了 View 的接口，Presenter 的接口，Model 的接口，以及 Model 的回调接口，方便管理和拓展。 1234567891011121314151617181920public interface LoginContract &#123; interface View extends BaseView &#123; void setUserNameError(String msg); void setPwdError(String msg); &#125; // 单纯地只是为了便于管理 interface Presenter &#123; boolean checkData(String phoneNum, String pwd); void login(String phoneNum, String pwd); &#125; // 登录的回调接口 interface loginListener &#123; void onSuccess(); void onFailure(); &#125; interface Model &#123; void login(String username, String pwd, loginListener loginListener); &#125;&#125; View 实现： 集成 BaseActivity，实例化对应的 presenter，实现对应的抽象方法以及 View 接口的方法，做一些初始化及控件监听工作即可。 1234567// 通过具体实现抽象方法，实例化 presenterprivate LoginPresenter mPresenter;@Override protected LoginPresenter createPresenter() &#123; mPresenter = new LoginPresenter(); return mPresenter; &#125; Presenter 实现： 继承 BasePresenter 一是实例化 View 及 Model 引用，其中 View 引用，通过getView() 方法拿到，而 Model 引用通过构造方法拿到。二就是作为 View 和 Presenter 的沟通桥梁，实现具体的业务逻辑。 12345// getView();拿到 View 的引用。 private LoginModel loginModel; public LoginPresenter() &#123; loginModel = new LoginModel(); &#125; Model 实现： 暂时没有大的改进，主要为获取数据，通过回调接口返回信息给 Presenter 层，再由 Presenter 层调用 View 层方法，更新UI。 总结 Base 基类功能更加丰富，减少大量冗余代码。 避免了一些 内存泄漏和空指针的问题。 契约类便于管理接口和扩展功能。 引入泛型，支持的业务场景更好，代码更加优雅。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MVP架构学习(二)之Google 官方Demo学习]]></title>
      <url>%2F2018%2F04%2F16%2FMVP%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%E4%B9%8BGoogle-%E5%AE%98%E6%96%B9Demo%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[MVP架构学习（二）之 Google 官方 Demo 学习前言在了解了 MVP 架构的大致模式后，学习了 Google 官方提供的 MVP Demo，并不是说官方的就是规范，没有最好的架构，只有最合适的架构。（手动滑稽）模仿官方 Demo 实现了一个登录功能。 Base 基类1234public interface BaseView&lt;T&gt; &#123; // 将 View 层同 Presenter 绑定的抽象方法 void setPresenter(T presenter);&#125; 12345public interface BasePresenter &#123; // presenter 调用 model 开始获取数据并调用 view 中的方法初始化界面 // 调用时机是 onResume() 方法中 void start();&#125; 契约类Google 将 View 接口 和 Presenter 接口放到一个「契约类」中，便于管理和维护，值得借鉴。 1234567891011121314151617181920212223// 一个契约类，便于管理 View 和 Presenter 的接口public interface LoginContract &#123; interface View extends BaseView&lt;Presenter&gt;&#123; void showProgress(); void dismissProgress(); void setUserNameError(String msg); void setPwdError(String msg); &#125; interface Presenter extends BasePresenter&#123; boolean checkData(String phoneNum,String pwd); void login(String phoneNum,String pwd); &#125; // 登录的回调接口 interface loginListener&#123; void onSuccess(); void onFailure(); &#125; interface Model &#123; void login(String username,String pwd,loginListener loginListener); &#125;&#125; View 层实现这里我使用的是直接用 Activity 实现，并没有使用官方的 Activity + Fragment 来实现，只负责 UI 显示与控件的监听事件。此 Activity 实现 View 接口中的所有方法，供 Presenter 层调用；同时，持有 Presenter 的引用，也可以调用 Presenter 层的具体的业务逻辑方法。 123456789101112 private LoginContract.Presenter mPresenter; //这样写，调用 LoginPresenter 的构造方法，而 LoginActivity 里面实现了 setPresenter()方法 //同时，setPresenter() 方法也在构造方法中调用，这样就相当于实例化 Presenter //presenter = new new LoginPresenter(this); //同时也将 View 传递到 presenter，实例化 presenter中的view new LoginPresenter(this);.....@Override public void setPresenter(LoginContract.Presenter presenter) &#123; this.mPresenter = presenter; &#125; 这是实例化 presenter 的一种方法。 Model 层实现这里我暂时还没有做真正的网络操作，做了下模拟登录。需要定义 Model 接口，便于管理 Model 类的操作。同时定义了回调接口，在 Presenter 层中具体实现。这样就实现了 Presenter 层调用 Model 层获取数据，同时将结果回调给 Presenter 层，再通过 View 层更新 UI。 Presenter 层实现Presenter 层应该是最重的一个部分，在里面需要实现业务逻辑方法。持有 View 和 Model 的引用，负责 View 与 Model 的通信。 123456789private LoginContract.View mLoginView ;private LoginModel loginModel;// 通过构造方法，实例化 View 及 Model的引用，同时实例化 View 层的 Presenter 引用。public LoginPresenter(LoginContract.View mLoginView)&#123; this.mLoginView = mLoginView; loginModel = new LoginModel(); mLoginView.setPresenter(this);&#125; 12345678910111213@Overridepublic void login(String username,String pwd) &#123; loginModel.login(username, pwd, new LoginContract.loginListener() &#123; @Override public void onSuccess() &#123; mLoginView.showMyToast("登录成功!"); &#125; @Override public void onFailure() &#123; mLoginView.showMyToast("登录失败"); &#125; &#125;);&#125; 通过回调接口，对数据操作做出对应的 UI 操作。 总结契约类、实例化 Presenter、实例化 Model、View 的方式可以借鉴。但是封装的还是太过简单了，Base 类可以进行进一步的优化，否则，契约类中的接口估计会太多了。Presenter 和 View 层都是用接口实现，是否是必须的，感觉有点过于设计了，造成代码冗余。下一步的优化：升级 Base 类，加入一些异常处理的判断，譬如：内存泄漏，空指针等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MVP架构学习(一)之概述]]></title>
      <url>%2F2018%2F04%2F16%2FMVP%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0-%E4%B8%80-%E4%B9%8B%E6%A6%82%E8%BF%B0%2F</url>
      <content type="text"><![CDATA[前言原生MVC： 遇到大规模的应用时，就会变得代码难读，不好维护，无法测试的窘境。 对于经典的 Android MVC 框架来说，如果只是简单的应用，业务逻辑写到 Activity 下面并无太多问题，但是业务逻辑逐渐变得复杂起来，每个页面之间有不同的数据交互和业务交流时，Activity 的代码的可读性、维护性变得很差。 总结来说：构建框架的最终目的是增强项目代码的可读性、复用性、维护性和方便测试。 MVP同MVC对比 MVC模式原生的 Android 架构，自然就会形成 MVC 架构，layout.xml 充当 View 层，Activity 充当 Controller 层，一些 JavaBean 和 数据操作的类充当 Model 层。但是由于 View 层的控制能力较弱，如果 UI 需要动态地改变，必须在 Activity 中改变 UI。所以，Activity 里既有业务逻辑，又有 UI 控制的代码，同一个模块承担了两种职责。再者，Model 和 View 互相感知，耦合严重。 MVP模式Model 层和 View 层不再相互感知，View 层通过 Presenter 层调用 Model 层，实现解耦，Model 层通过回调函数将获取的数据返回给 Presenter 层，Presenter 层再通过 View 的接口实现 View 的更新。同时，View 层由 Activity或Fragment 承担，责任单一划分。但是 View 层和 Presenter 层是相互感知的，为了解决这个问题，两者之间通过接口进行通信，来实现代码的解耦和可拓展性。 MVP结构M层： JavaBean、获取数据的操作类等（本地数据库或网络数据）。 V层： Activity 或 Fragment 负责 View 的显示与监听事件。 P层： 所有的业务逻辑代码实现，不含任何 Android API，纯的 Java 类，负责 M 层和 V 层之间的通信。 MVP优点 Model 和 View 完全分离，可以修改视图而不影响模型。 可以更高效地使用模型，因为所有的交互发生在一个地方——Presenter 内部。 我们可以将一个 Presenter 用于多个视图，而不需要改变 Presenter 的逻辑。这个特性非常适合模型变化频繁。 如果我们将逻辑放入 Presenter 中，那么我们就可以脱离用户接口来测试这些逻辑。（单元测试） 把业务逻辑抽到 Presenter 中去，避免后台线程引用着 Activity 导致 Activity 的资源无法回收引起内存泄漏和 OOM。 MVP缺点 View 层和 Prestenter 层交互频繁。 代码量多，类变多了。 MVP大致实现 定义一个 interface 接口 XView，对应的Activity、Fragment实现这个 interface。 编写 Model，里面的业务逻辑主要包括网络请求获取数据，数据库读取等耗时操作，通过 M 层，回调给 P 层，通知 V 层更新 UI。 编写 Presenter，P 层中持有 V 和 M 的引用，实现 P 层的回调，并且回调给 V层更新。 Activity 中调用 P 层执行业务逻辑，更新 UI。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[流行的四大 APP 开发模式]]></title>
      <url>%2F2018%2F04%2F03%2F%E6%B5%81%E8%A1%8C%E7%9A%84%E5%9B%9B%E5%A4%A7-APP-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[1.Native APP基于 Android 或 iOS 系统，体验最好，交互最好，性能最好，使用 Java/Kotlin (Android) Object-C/Swift (iOS)，调用原生的API，但是不能跨平台，而且学习成本高，纯粹的原生开发很少。 2.Web APP页面部署在服务器上，可以跨平台，开发成本低，但是体验较差，通过浏览器来使用，利用 web 开发技术进行开发。 同 web 的区别： 主要是功能方面的区别，传统的 web 功能比较单一，主要是做一些内容展示的功能，而 web app 功能比较复杂，交互比较强，例如 web qq、web 邮箱等。 3.Hybrid APP混合开发，也是现在 APP 的主流模式。Native 通过 JSBridge 等方法提供统一的 API，然后用 HTML5 + JS 来写实际逻辑，调用 API，这种模式下，由于 Android、IOS 的 API 一般具有一致性，而且最终的页面也是在 WebView 中显示，所以有跨平台效果。但是性能仍然有较大损耗，不适用于交互性较强的 APP。 JSBridge: 定义 Native 和 JS 的通信，Native 只通过一个固定的桥对象调用 JS，JS也只通过固定的桥对象调用 Native。基本原理是： H5通过某种方式触发一个 url -&gt; Native 捕获到 url，进行分析 -&gt; 原生做处理 -&gt; Native 调用 H5 的 JSBridge 对象传递回调。 HBuilder、Appcan 等用前端开发好之后，再自行打包。 4.React Native &amp; weexRN，Facebook 在当初深入研究 Hybrid 开发之后，觉得这种模式有先天的缺陷，所以自行研究，不同于 H5，也不同于原生。 优点 开发成本大于 Hybrid 模式，但是小于原生模式，大部分代码可以复用。这种模式时统一用 JS 写代码，提供了组件化开发的思想，如果后续代码封装的好，很多功能可以复用。 性能体验高于 Hybrid，不逊色于原生。「虚拟dom」、这种模式可以认为是 JS 写原生，即页面用 JS 写，然后原生通过 Bridge 技术分析 JS，将 JS 内容单独渲染成原生 Android 和 iOS。 开发人员单一技术栈，一次学习，跨平台开发。这种模式是统一由 JS 编写，有着独特的语法。学习一次，同时开发 Android 、iOS 平台。 缺点 虽然可以部分跨平台，但并不是 Hybrid 中的一次编写，两次运行那种，而是不同平台的代码有所区别。这种模式实际上还是 JS 来写原生，所以 Android 和 iOS 中的原生代码会有区别，如果需要跨平台，对开发人员有一定的要求。 学习成本，坑有不少。 5.直观对比 Native App Web App Hybrid App React App 原生体验 优秀 差 良好 接近优秀 是否支持设备访问底层 是 否 是 是 网络要求 支持离线 依赖网络 支持离线 支持离线 编程语言 Java/OC/Swift js+html+css3 js+html+css3 js,jsx APP 发布 App Store Web 服务器 App Store App Store 6.如何选择 通常情况下，不选择 Web App。 如果对体验、性能要求极致，不考虑成本和时间，可以选择原生 App。 考虑跨平台，对体验要求不高可以选择 hybrid App。 考虑跨平台，对体验要求较高，并且又一定的技术积累，可以选择 RN。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx 反向代理配置二级域名]]></title>
      <url>%2F2018%2F03%2F23%2Fnginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%2F</url>
      <content type="text"><![CDATA[nginx 反向代理配置二级域名1. 前言最近在学 app 后端，我的 spring-boot 项目运行在 8080 端口，发现在访问 API 的时候，必须要加上对应的端口号（除非是默认的80端口号），这样就很不舒服，想着如何可以用一个二级域名指向主机的端口号，这样会看起来很舒服，也便于管理。 2.解决方法 配置域名 DNS 解析为隐式Url ，这样它就会把一个二级域名指向对应的端口， 只是简单地实现一个跳转功能，但是后面加 API 的路径，或者加一些参数都是不行的，除非你指向对应的文件。在记录那行写上 http://cenyan.xyz/hello/say，而且这样后面加参数也是不行。所以这种方法写 API不合适。 第二种方式来了，就是 DNS A类型，二级域名指向主机，然后通过 nginx 反向代理指向本机对应的端口。 安装 nginx：apt-get install nginx 完全卸载 nginx：sudo apt-get remove nginx nginx-common&amp;&amp;sudo apt-get purge nginx nginx-common&amp;&amp;sudo apt-get autoremove&amp;&amp;sudo apt-get remove nginx-full nginx-common 运行 nginx：nginx 重新运行 nginx：nginx -s reload 不要使用 service nginx start service nginx stop ,会出现莫名其妙的问题 在 etc/nginx/nginx.conf 文件中 http 块中添加 server 块： 这样在访问 api.cenyan.xyz 的时候就可以访问到主机的 8080 端口了。 修改完毕后，重新加载 nginx nginx -s reload 即可。 3. 总结这可能是最简单的 nginx 反向代理了吧，还有负载均衡的一些内容，暂时也用不到，有空可以学习下nginx 的相关知识，真的，程序员需要懂一些后端的知识。持续学习！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[URI、URL、URN 的区别]]></title>
      <url>%2F2017%2F09%2F13%2FURI%20%E4%B8%8E%20URL%20%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[1. 定义：URI: Uniform Resource Identifier，统一资源标识符 URL: Uniform Resource Location，统一资源定位符 URL结构是：协议：//主机名+端口/资源路径 URN： Uniform Resource Name，统一资源名称 2. 三者关系URI 包括 URL 和 URN，URI 用来标识一个互联网的资源，是一种高级的抽象。URL 和 URN 是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何定位这个资源，如何访问到这个资源；而 URN 是通过名字来标识资源，mailto:java-net@java.sun.com ，应用主要为磁力链接。 所有的 URL 都是 URI，但是 URI 不一定都是 URL，只有带有访问协议的才是 URL，通俗地讲，如果唯一地标识一个人，身份证号可以唯一标识一个人，但是不能找到这个人；但是如果利用 人类访问协议：//hdu.edu.cn/张三 这样也可以唯一标识一个人，并能找到这个人，这样就是 URL 了，当然也是 URI。 三者关系如下图： 3. 具体例子 ftp://ftp.is.co.za/rfc/rfc1808.txt (also a URL because of the protocol) http://www.ietf.org/rfc/rfc2396.txt (also a URL because of the protocol) ldap://[2001:db8::7]/c=GB?objectClass?one (also a URL because of the protocol) mailto:John.Doe@example.com (also a URL because of the protocol) news:comp.infosystems.www.servers.unix (also a URL because of the protocol) tel:+1-816-555-1212 telnet://192.0.2.16:80/ (also a URL because of the protocol) urn:oasis:names:specification:docbook:dtd:xml:4.1.2 这些都是 URI，但是只有提供了访问协议的才是 URL。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP 学习]]></title>
      <url>%2F2017%2F08%2F28%2FHTTP-%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[1. HTTP 请求报文格式请求行、请求头、请求体 请求行：请求方法、请求地址、协议版本 请求方法：GET、POST、DELETE、PUT 比较常用 请求地址：URL 组成 PATH 是 URL 主机以后的部分，即包含了Query String。 2. HTTP 相应报文格式响应状态行、响应头、响应体 3. HeaderHeader 可用于传递一些附加信息，格式：键: 值 ，注意：冒号后面有一个空格 12Content-Length: 1024Content-Type: text/plain 4. 请求体的 3 种形式 移动开发者常见，请求体是任意类型，服务器不会解析请求体，请求体的处理需要自己解析，如 POST JSON 时候就是这类 第二种和第三种都有固定格式，是服务器端开发人员最先了解的两种。这里的格式要求就是 URL 中的 Query String 的格式要求：多个键值对之间用 &amp; 连接，键与值之间用 = 连接 第三种请求体的请求体被分成为多个部分，文件上传时会被使用，这种格式最先应该是被用于邮件传输中，每个字段/文件都被boundary（Content-Type中指定）分成单独的段，每段以-- 加 boundary开头，然后是该段的描述头，描述头之后空一行接内容，请求结束的标制为boundary后面加-- 4. TCP 协议的三次握手与四次挥手TCP 协议作为底层的传输协议，在进行数据连接是，客户端和服务端要进行三次握手才能保证 client 与 server 能互相相应；在数据传输完成后，需要断开连接，要进行四次挥手，才能断开连接。 5. 计算机网络的一些基本知识计算机网络从下到上分为7层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层 IP协议 位于网络层 TCP协议/UDP协议 位于传输层 HTTP协议 位于应用层 Socket 不是一种协议，而是对 TCP/UDP 协议的一种封装，对外提供了 API 接口，方便调用 HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。 TCP/UDP 区别： TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上（实际上也很大程度上保证了）保证了连接的可靠性；而UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议。 也正由于1所说的特点，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。 知道了TCP和UDP的区别，就不难理解为何采用TCP传输协议的MSN比采用UDP的QQ传输文件慢了，但并不能说QQ的通信是不安全的，因为程序员可以手动对UDP的数据收发进行验证，比如发送方对每个数据包进行编号然后由接收方进行验证啊什么的，即使是这样，UDP因为在底层协议的封装上没有采用类似TCP的“三次握手”而实现了TCP所无法达到的传输效率。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git常用命令]]></title>
      <url>%2F2017%2F07%2F16%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[配置信息 全局配置个人信息，如果想只配置本项目的信息，去掉--global git config --global user.name yourname git config --global user.email youremail 提高工作效率的方式，别名配置 git config --global alias.别名 原始命令 git config –global alias.co checkout 配置高亮显示 git config --global color.status auto 查看状态高亮显示 git config --global color.branch auto 分支名高亮 git confit --global color.ui auto 自动高亮 基础命令 git init 初始化 git status 查看状态 git add 文件名 添加文件到暂存区 git add . 添加当前目录下所有文件到暂存区 需注意的是，git add 命令不是执行一次就可以，每次修改项目内容后，都需要执行 git add 命令进行更新 git commit -m 通过 -m 添加提交的简短信息 查看项目历史记录 git log 下载程序 git clone yourProjectUrl 不同分支 当你需要开发一个新功能时，可以新建一个新的分支，并且切换到该分支开发，当功能完成后，你将该分支提交到本地，然后再切换到主分支并且合并，完成新功能的开发 git branch yourbranchName 创建一个新的分支 git branch 查看当前所有分支 git branch -d 分支名 删除某一分支 注意，不能在本分支删除本分支，必须切换到其他分支 git checkout yourbranchName 切换到一个分支 git checkout yourProjectName 回滚操作，将文件回滚到最近一次提交的状态 合并分支 假设我们新开一个分支 net 新增一个功能，开发成功了，我们需要将新功能合并到 master 分支，如果没有冲突，那么 net 分支将与 master 分支合并 git merge net 解决冲突 git merge 中，如果没有冲突，才会自动合并，否则将会提出哪些文件产生了冲突。产生冲突的原因是因为很多个开发人员修改了同一个文件的相同地方导致，导致 Git 系统不知道用谁的代码，此时就需要开发人员自己选择，选择其中一份代码，并且将其他的代码删除。当然也得将&lt;&lt;&lt;&lt;&lt;&lt;HEAD 和 ========= 之类的冲突标识删除，然后重新 add commit 即可以提交 为版本打一个标签 在完成所有功能，并且经过测试后，我们通常会为这个版本打一个标签，这是一个非常重要的功能，便于后续版本检索与维护 git tag -a v1.o -m 后面加简短的信息 git tag -d 标签名 来删除标签 git show 标签名 查看该分支的具体信息 同远程 Git 仓库交互 将本地仓库的代码提交到 Git 仓库 git remote add origin 你的git仓库地址 origin 是给远程 Git 仓库起的一个别名，通常都这样起，然后将项目与该远程仓库关联 注意：一个项目可以和多个远程仓库关联的，这样就可以在 push 或者 pull 时选用不同的远程仓库名进行操作 git push resp br 将项目推送到远程仓库 resp: 远程仓库名 br: 远程仓库的一个分支 git push origin master : master 第一个 master 是本地仓库的分支，第二个是远程仓库的分支，如果两个仓库的分支一样，可以简化为 git push origin master git push orign : net 删除 origin 远程仓库的 net 分支 更新最新的代码 一般的话，先从远程仓库的代码 pull 到本地，确保合并成功，如果有冲突，要解决好冲突，然后再将本地代码 push 到远程仓库 git pull resp br git pull origin msater 遇到的几个问题 在 pull 的时候，因为两个仓库不同，出现了refusing to merge unrelated histories 问题，解决办法是：git pull origin master --allow-unrelated-histories 即可将远程代码 pull 下来 但是，在合并的时候又出现了一个非要让你写 message 的框框，解决办法为 1.按键盘字母 i 进入insert模式 2.修改最上面那行黄色合并信息,可以不修改 3.按键盘左上角”Esc” 4.输入”:wq”,注意是冒号+wq,按回车键即可 可以直接执行 3、4 步即可 Fork + Pull Request 多人协作模式先 Fork 一份到自己的仓库，这个派生系统没有独立的缺陷追踪系统，必须利用原来项目的缺陷追踪系统。 然后 clone 到本地，在修改完成后，先提交到自己的本地仓库，通过Pull Request 方式，将自己的代码请求更新到原仓库。如果原仓库的主人同意了请求，主仓库就会合并了代码，使项目变得更加稳定、强大。 但是，在 Pull Request 之前，要首先从原仓库把最新的代码 Pull 下拉，以免改动了同一个地方，引起冲突，如果有冲突，解决冲突，然后再提交到自己的远程仓库，通过 Pull Request 向原仓库提交代码合并的请求。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Kotlin 学习笔记（一）环境配置]]></title>
      <url>%2F2017%2F05%2F23%2FKotlin-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[在前面说几句Google I/O 正式宣布将 Kotlin 作为 Android 的官方开发语言，大家学习 Kotlin 的热情瞬间高涨。今天就给大家分享点开发 Kotlin 的环境配置经验。虽然简单，但还是有一点坑。 安装插件 直接在 setting -&gt; plugin 里面搜索 Kotlin 安装后重启 AS，这样就集成了开发 Kotlin 的最基础的环境，对了不要忘记配置 Kotlin 的依赖，可以用插件一键自动生成 Tools -&gt; Kotlin -&gt; Configure Kotlin in Project ，然后 sync gradle 即可。 我是看 Kotlin For Android Developer 中文译文搭建的，里面要求在安装一个叫Kotlin Extensions For Android 的一个插件，它的作用是摆脱 findViewById() 的烦恼，可以直接引用 xml 的 id，作为变量名称。可是我怎么都找不到这个插件，在 JetBrans 官网也找不到，不知道是怎么回事。但是似乎仍能导入相应的包import kotlinx.android.synthetic.main.activity_main.* ，本以为难道两个插件功能叠加起来了，但在编译的时候还是出错了，unresolved reference kotlinx 找不到 kotlinx 的引用，在 Google 之后，终于解决了这个问题。 在 project level 的 gradle 下添加如下代码： 123456&gt; buildscript &#123;&gt; dependencies &#123;&gt; classpath "org.jetbrains.kotlin:kotlin-android-extensions:$kotlin_version"&gt; &#125;&gt; &#125;&gt; &gt; 在 app level 的 gradle 下添加如下代码： 12&gt; apply plugin: 'kotlin-android-extensions'&gt; 最终，我没有下载 Kotlin Extensions For Android 这样个插件，而是通过手动添加 gradle 代码解决了这个问题。 暂时不推荐安装anko 插件，安装后，重新启动 AS 时，会出现打不开的现象，这样就很烦。 总结官网上说是，AS 3.0 会直接集成 Kotlin，但是 3.0 好像没放出来。配置环境就是安装插件的问题，坑可能还有不少，一步步来填吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[鉴势平板开发总结]]></title>
      <url>%2F2017%2F05%2F17%2F%E9%89%B4%E5%8A%BF%E5%B9%B3%E6%9D%BF%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[写在前面的话大概花了 10 天左右的时间，完成了「鉴势」平板的开发工作，整体难度到没有多大，但还是学习并巩固了不少知识，在此记录。 界面布局 第一次做这种表格类型的 APP，也没想太多，直接把表格的线一个个的 View 画出来了。着重使用 weight 属性，能简化不少问题。画表格线，可以通过设置背景来实现，这样应该会简单一点。tablelayout 也可以尝试一下。 应对这种多控件的布局，ButterKnife 必不可少，如果嫌这个也慢的话，也可以使用自动生成ButterKnife 注解的插件ButterKnife Zelezny ，显著提高生产效率。 id 命名：感觉我命名的有点长，但感觉这样才好分辨。 资源管理 由于使用的常量太多，建立一个常量类 颜色、尺寸、字符串资源统一管理 DatePickerDialog熟悉了这个原生的日期选择控件，也可以使用DialogFragment 的方式来管理对话框（暂未实现）。 Spinner熟悉了这个原生的下拉列表控件，使用了最简单的设置字符串数组的方式来实现。也可以自己设置adapter ，自定义列表的样式。 Android 数据持久化技术 SQLite 3：这个项目使用了 SQLite 存放了一张 user 表，用于用户的注册和登录。了解了基本的 SQLite 操作，安装了一个 SQLite 可视化工具。 SharedPreference：一种轻量级的 Android 存储数据的方式，以键值对的方式保存，通过这个东西，实现了记住密码的操作。 Java I/O 流感觉自己还不是很熟悉，基本知识还要加强。 1234567891011121314private void writeScada(String content) &#123; File file = getContext().getExternalFilesDir(Environment.DIRECTORY_DCIM); BufferedOutputStream bos = null; try &#123; bos = new BufferedOutputStream(new FileOutputStream(new File(file, "SCADA 系统信息安全自查表.doc"))); bos.write(content.getBytes()); bos.flush(); bos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 其他这次采用了按功能分包的方式，感觉比以前功能拆分更加清晰。 后记这次开发，发现自己很多基础的东西都掌握的不太好，这是以后需要着重加强的一点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HelloWorld 社团一年总结]]></title>
      <url>%2F2017%2F04%2F21%2FHelloWorld-%E7%A4%BE%E5%9B%A2%E4%B8%80%E5%B9%B4%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[时间过得真快，好像从去年当上 Android 组长，到现在要换届，真的只是一眨眼的功夫。但时间就是这样的，从自己出生到现在，何尝不是一眨眼的功夫呢？也许只有自己最清楚，自己这一年成长了多少，进步了多少。从大一的懵懵懂懂，学习课堂上的知识，到现在有选择性的逃课，做自己喜欢的事；由大一的有点放不开，到现在的乐观、开朗、脸皮超厚……谁知道我经历了什么（哈哈）。我想这就是成长，我喜欢这种感觉，也会慢慢变成自己心目中理想的模样。 好像是要说社团经历啊，按着时间线来吧。最初选择当 Android 组长的初衷，我还记得：有这个身份做驱动，快速提高自己的 Android 开发技术。大一的时候，确实我们社团 Android 学习的氛围几乎为 0 ，也没有系统的学习相关知识，Java 基础 和一些 Android 基础都不过关。于是在大一的那个暑假，我开始了恶补，学习了 Java 和 Android 的一些基础知识。同时，在那个暑假的时候，还给大二的同学布置了学习任务，每周还要收他们的学习汇报（大多数情况都是我主动去问他们要，wuwu~）。体会到了身为 Android 组长责任感，同时看到他们的学习进度，也会激励自己去学习，那时候主要看视频，也算是浅浅的入门了吧，不过只会敲 demo，对一些基础的知识有了了解。 暑假休息完，社团第一次开会，我记得王琦问我们「暑假干了什么？」那会感觉回答个问题都会有点紧张，感觉还是没有融入社团，那会王琦好像也有点「严肃」，或许是吧。不过现在，社长真是变了很多，从大一时见到她的少言寡语，到现在的整个人的提高，很有思想。说自己吧，就开会这件事，上学期的话，首先是招新的事，然后呢就是问 Android 组的学习情况，下学期基本上没啥事了，大部分是行政方面的。基本上每周一次的会议，坚持了整整两个学期，当真不容易。首先我们大二这波人，真的还不错，不说技术方面，这种责任感也是不容易的。主席团的三位领导也是很辛苦，都是责任感啊，上一届的社团办的很不错，「不要毁掉江山」可能是很大的驱动吧。 招新的话，我也不知道到底自己的选择是否正确，也不知道自己培养他们的方法是否合适，但我始终认为一条准则，真正想学的人，一定会自己找资源，找方法，主动找我求教的，这是最基础的自学能力。当然，我也尽量为他们提供了足够的资源与氛围，什么学习资料，要求他们一周在群里说一下本周总结（虽然慢慢地不做了），开会教他们一些基础的知识，尽量让他们少走弯路，当然也会告诉他们一些框架什么的，最后我给他们布置了一个做一个「阅读类 APP」的任务，如果他们能做出来，能力肯定能进步一大截。MVP + RxJava + Retrofit，再加上 Material Design 的设计，一定会给自己一个满意的交待的。不过，这个学期，由于自己也一直在忙，准备各种比赛，只开过一次会，我想还会最后再开一次吧。现在估计他们进度不会太好，最后开会的时候再和他们说一下吧。这算是一种遗憾吧，不过自己确实在忙的过程中提高了很多，不管是技术还是为人处事。 这个学期，我们社团的活动较少，没有怎么出去玩，去过浙工大一次（但没有看到所谓的小和山），看过次电影，出去聚过餐吧。以后活动还是要多一点，否则还是玩不到一块的。 社团的话，要做活动，摆摊是很重要的一部分，我自己对行政什么的不感兴趣，也没有怎么参与。只是听命令去摆摊就好了，不过我想着不要为了摆摊而摆摊，比如今天的「后续宣传」，真的没什么用，我们这个类型的沙龙，其实通过摆摊去听的真是没几个，也不需要多少人去听。或许是为了让同学知道我们社团办了这个活动，前期宣传是很重要的，但是后续宣传真是没啥用。就算有人知道了，到下个学期不就忘了吗？我们还是要宣传呀，只有摆摊人员干坐在那里。感觉，今年的摆摊没有大一的 Hackthon 的那种激情。 关于社团管理方面，现在我们的层级结构是 主席团 - &gt; 组长、部长 - &gt; 小干事。算是比较传统的架构吧，两头的结构我觉得没啥好变的，主要是中间这层，这个学期，每个组的都在自己的小圈子里学习。真正要做项目的时候，必然是很多组一起干的，前端、移动开发组不知道如何和后台交互，后台也不知道自己学的到底有什么用。希望下一届在技术部这块一定要好好想想，给干事们找活干。感觉还是需要一个技术部长，定义举行社团内的技术沙龙，各组长也可以去演讲，在这个氛围下，给真正想学技术的同学提供一条途径吧。在组长的就任仪式上，罗峡说过，「这个社团已经成为生活中不可缺少的一部分」，我想那是的为并没有这种感觉，主要是社团的 Android 技术氛围并不好，也没真正学到什么东西。而前端的大神很多，他也有机会得到更多交流和进步的机会。我想通过这种沙龙和项目活动，增强干事的社团归属感吧。不过，看似前景很不错，但真正执行起来还是有很多阻碍的。 社长，真是我很钦佩的一个人，可能在她身上能看到自己的一点影子吧。一点点的改变自己，一点点的成长，不过她在管理社团方面真是很棒。我的话，差选了，管理也真是一门学问呢。以后也努力提高吧。以后一定会在路上看到你打招呼的。哈哈。 忘了，作为 Android 组长，这个身份也让我认识了不少人，交了一些志同道合的朋友，给了我很多帮助。这些看不见的东西，我觉得可能是最重要的。 最后总结一下吧，一年的 Android 组长的身份，暑假学习、收学习汇报、招新、讲课、开会、摆摊、办活动、出去玩，大概就这样吧。总体来说，自己还是得到了很多，不知道给社团贡献了多少，给自己勉强打个 80 分吧。自己技术得到了提高，为人处事也有了一些进步，成长了不少。不后悔当这一年的 Android 组长。由于对社团管理没啥兴趣，还是想继续提高技术，所以我打算不留了。不过，社团的话，也可以留下我的名字，有什么需要帮忙的，我也一定会尽力去做的。 做自己喜欢的事 —— 生活就是这么简单。 田浩宇 2017.4.22]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android 回调机制理解]]></title>
      <url>%2F2017%2F04%2F16%2FAndroid-%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[前言经常听什么「回调」啊，Android 框架里什么生命周期啊，各种监听事件啊，直白一点，各种带「on」的方法，都是「回调方法」，一直想了解，但是一直没理解清楚。现在参考了网上的一些例子，梳理一下。 PS：首先要清楚 Java 中接口的相关概念，其次要有一点「事件分发机制」的了解（暂时还没弄清楚，以后写博客总结）。 概念A 类中定义一个方法，这个方法中用到一个接口变量和该接口中的方法，但这个接口中的抽象方法需要 B 类去实现，B类实现该方法后，它本身不会调用该方法，而是传递给 A 类，供 A 类调用，这种机制称为「回调」。 实战下面我们拿 button 的点击事件来分析模拟： 首先，在 View 类中，找到interface OnClickListener ： 123public interface OnClickListener()&#123; void onClick(View var);&#125; 这是定义的接口，然后还有对应的接口变量：public OnClickListener mOnClickListener 。 其次，在 View 类中我们能找到 setOnClickListener(OnClickListener l) 方法： 123456public void setOnClickListener(OnClickListener l)&#123; if(!isClickable())&#123; setClickable(true); &#125; getListenerInfo().mOnClickListener = l;&#125; 该方法中，将 OnClickListener l 赋值给了 成员变量 mOnClickListener。 我们继续往下找，找到在 performClick() 方法中，执行了我们的onClick() 方法。 12345678910public boolean performClick() &#123; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); return true; &#125; return false; &#125; 这就是概念中所说的，A 类中接口变量调用抽象方法的方法，也就是 B 类回调 A 类的方法。 在某一个 Activity 中，实现 button 的点击事件。 123456button.setOnClickListener(new OnClickListener&#123; @Override public void onClick(View view)&#123; //做具体的操作 &#125;&#125;); 这里就将一个接口的实现类作为参数传入 View 类中的 setOnClickListener() 方法中，从而为 View 类中的 成员变量 mOnCLickLisetener 赋值。 接着就是在父类中，也就是 View 类中执行 onClick() 方法，为什么会在父类中执行该方法呢？这就要说到 Android 中的另一个重要的机制——「事件分发机制」。当我们手指触摸到手机屏幕，就一定会执行dispatchTouchEvent(MotionEvent event) 方法。（此处省略10000字） 简单点说就是：通过事件分发机制，最终调用了performClick() 方法，从而执行了onClick() 方法。 123if(!post(mPerformClick))&#123; performClick();&#125; 为什么要回调这里体现了Java 中的「万事万物皆为对象」的理念，我们需要将普通物体的特性抽象出来，共性之中又有特性，每种特性交由不同的情况处理，通过接口暴露的方法可以减少很多重复，代码更加优雅。 例如：Button 和 TextView 都继承于 View，在做点击事件时，点击的具体逻辑是不同的。我点Button 可能弹出一个 toast，而点击 TextView 弹出一个 Notifaction，这时候回调的好处就体现出来了，因为 Android 对外暴露了 onClickListener() 接口，里面要去具体实现 onClick() 方法，就在这我们就可以随意定制了。而 View 的话，不管你如何实现，它只负责调用 onClick() 方法。 这样，代码更加简洁，逻辑也更加清晰，也算多态的一种实现吧。 参考文章Android 中的回调函数机制解析 android 中的回调 Android 回调函数机制那点事]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java 接口深入理解]]></title>
      <url>%2F2017%2F04%2F16%2FJava-%E6%8E%A5%E5%8F%A3%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[直观印象 抽象方法的集合，是一种对行为的抽象 是一种程序之间的一种「协议」或者「规范」 实现「多态」的一种手段 注意事项 接口本身不是「类」，我们不能实例化一个接口，如 new Runnable() 肯定是错误的，我们只能 new 它的实现类。 interface 的所有方法访问权限自动被声明public 及 abstract 。确切的说，只能声明为public 和 abstract 。 接口中可以定义「成员变量」，或者说是不可变的常量，因为接口中的「成员变量」会自动变为public static final 。可以通过实现类名直接访问ImplementClass.name 。 接口中不存在实现的方法。 实现接口的非抽象类 必须要实现该接口的所有方法。抽象类可以不用实现。 不能使用new 操作符来实例化一个接口，但可以声明一个接口变量，该变量必须引用一个实现该接口的实现类。 实现多接口的时候一定要避免方法名的重复。 为什么要使用接口 接口是一种规范，一种「招牌」，便于查看，便于维护和拓展 知乎上详细的例子 接口就是个招牌。 比如说你今年放假出去杭州旅游，玩了一上午，你也有点饿了，突然看到前面有个店子，上面挂着KFC，然后你就知道今天中饭有着落了。 KFC就是接口，我们看到了这个接口，就知道这个店会卖炸鸡腿（实现接口）。 那么为神马我们要去定义一个接口涅，这个店可以直接卖炸鸡腿啊（直接写实现方法），是的，这个店可以直接卖炸鸡腿，但没有挂KFC的招牌，我们就不能直接简单粗暴的冲进去叫服务员给两个炸鸡腿了。 要么，我们就要进去问，你这里卖不卖炸鸡腿啊，卖不卖汉堡啊，卖不卖圣代啊（这就是反射）。很显然，这样一家家的问实在是非常麻烦（反射性能很差）。 要么，我们就要记住，中山路108号卖炸鸡，黄山路45号卖炸鸡（硬编码），很显然这样我们要记住的很多很多东西（代码量剧增），而且，如果有新的店卖炸鸡腿，我们也不可能知道（不利于扩展）。 接口实现多态 知乎上详细的例子 接口的作用对于很多新手来说很不容易理解，我给大家举个例子。接口只是一个规范，所以里面的方法都是空的。假如我开了一个宠物粮店，声明所有宠物都可以来我这里买粮食，这就相当于一个接口， public interface PetRestaurant { public void buy();} 当一只狗看到了，知道自己是宠物，所以它去实现这个接口public class DogPet implements PetRestaurant { @Override public void buy() { System.out.println(“我是狗，我要买狗粮”); }}当一只猫看到了，知道自己也是宠物，所以也去实现这个接口public class CatPet implements PetRestaurant { @Override public void buy() { System.out.println(“我是猫，我要买猫粮”); } }当狗和猫来我的店之前，我是不知道他们到底是什么，但是当他们来到我的店，我就知道一个要猫粮食，一个要狗粮食。因为他们都实现了 我这个接口，都可以买。下面这个类相当于一个接待顾客的类，即店小二，他接待所有实现了我这个宠物店接口的动物，传进来一个PetRestaurant 类型的宠物，注意，这个PetRestaurant 是接口public class test { public void buy(PetRestaurant pet) { pet.buy(); }} 好了，这个时候我这个老板出现了，我可以给他们卖粮食了，相当于测试类public class Tests { public static void main(String[] args) { PetRestaurant dog = new DogPet(); //实例化一个狗，相当于把狗顾客实例化 PetRestaurant cat = new CatPet();//实例化一个猫，相当于把猫顾客实例化 test t = new test(); //实例化一个店小二 t.buy(cat); //把猫交给店小二 t.buy(dog); //把狗交给店小二 } }这样运行的结果就是我是猫，我要买猫粮我是狗，我要买狗粮 你知道吗，整个过程我这个店主其实根本不知道来的到底是猫是狗还是其他什么，我只要有一个店小二，把这些来的不知什么动物都全部交给店小二，店小二就知道怎么去卖了，因为这些狗啊猫啊都实现了我这个宠物店的接口，而店小二就负责接待所有实现了我这个接口的动物。这就有一个好处，假如明天来了一头小猪，只要它实现了我这个接口，我只管交给店小二处理就OK了，我这个店小二根本不需要变化，我这个店主也只需要实例化一下这个动物就OK你想，假如没有接口，会怎么办，来一个猫，我要去创造一个猫，还要实例化，来一只狗，我要创建一只狗，同样要实例化，还要配备专门的店小二去接待，就会相当麻烦。 接口和抽象类的区别 语法层次 抽象类实现 1234567public abstract class Demo&#123; abstract void method1(); void method2()&#123; // 可以实现 &#125;&#125; 接口实现 12345interface Demo&#123; void method1(); void method2(); //不可以被实现&#125; 抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。 对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。 设计层次 抽象层次不同 抽象类是对类抽象，而接口是对行为抽象。抽象类是对整个类整体抽象，包括属性、行为。但是接口只是对局部（行为）进行抽象。 跨域不同 抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类（即使没有相似特点）。我们知道抽象类是从子类发现公共部分，然后泛化成抽象类，子类继承该父类即可。但是接口不同，实现它的子类可以没有任何关系。例如：猫、狗可以抽象成一个动物类，具备叫的方法。鸟、飞机可以实现 fly 接口，但是鸟和飞机不能抽象成一个抽象类吧！ 设计层次不同 对于抽象类，它是自上而下来设计的，我们要先知道子类才能抽象出父类。而接口则不同，它根本不需要知道子类的存在，只需要定制一个「规范」即可。例如，我们只有一个猫类在这，你抽象出一个动物类，就有点过了。但如果有一个猫类、一个狗类，这时候你可以抽象出他们的共同点成一个动物类！ 对于接口，比如飞这个接口，我们根本不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口。 所以说：抽象类是自上而下设计的，而接口是自下而上设计的 。 参考文章 知乎回答 博客园回答]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手机万才项目总结]]></title>
      <url>%2F2017%2F04%2F11%2F%E6%89%8B%E6%9C%BA%E4%B8%87%E6%89%8D%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[前言经过寒假的筹备，从开学（2017.2.19）正式编码，到校赛正式答辩（2017.4.5），大概 1 个半月的时间，同赵俊文一同开发了我的第一个完整的项目——「手机万才」。在完成这个项目的过程中，无论是技术上还是管理上，都遇到了不少问题，幸运的是，最终都克服了。虽然最终答辩的时候，发挥的不是很理想，但还是获得了三等奖（还是可以接受的）。现在做个小小的总结吧，为自己 1 个半月的忙碌做个交待，也为今后少走弯路。 技术代码规范在之前写小 demo 的时候，没有觉得代码规范的重要性，当项目稍微大了点的时候，必须强迫自己做好代码规范，不仅方便自己编码，也方便别人合作。 目录结构 ​ 可以粗略地按照功能分类 命名规范类和接口： 类名必须使用驼峰 命名规则 eg : BookReadPlanAdd 方法命名： 方法名是一个动词，采用大小写混合的方式，第一个单词首字母小写，其后单词的首字母大写 eg : public void getBookName(); 变量命名： 临时变量一般取名 i，j，k，m，n，一般用于整型；c，d，e，一般用于字符型。 ​ 变量命名也必须采用驼峰规则，但是首字母必须小写。eg : bookName 成员变量命名： 同变量命名，但不要在私有变量前添加「m」字样。 常量命名： 类常量的声明全部大写，单词间用下划线隔开。 eg ： static final int MIN_WIDTH = 4; layout 命名： 全部单词小写，单词间以下划线分割，并且使用名词或名词词组 来命名 id命名： 全部单词小写，单词间以下划线分割，并且使用名词词组，并且要求能够通过 id 直接理解当前组件要实现的功能。 eg ； @+id/book_name_show 资源命名： layout 中所使用的所有资源（drawable，style 等）命名必须以全部单词小写，以下划线分割。 规约方法： 一个方法最好不要超过 15 行，如果方法太长，说明当前方法业务逻辑已经非常复杂，最好进行拆分，确保一个方法只做一件事。 参数和返回值： 一个方法的参数尽量不要超过 4 个。 神秘的数： 代码中不允许出现单独的数字、字符，如果必须出现，则必须将它们按照含义封装为静态常量。 访问控制： 如果没有足够理由，不要把实例或者类变量声明为公有。 编码技巧 定制基类可以自己定制各种基类 BaseActivity 、BaseFragment、BaseAdapter，可以将常用的方法等封装到里面，如：界面跳转、Toast、抽象初始化方法 init() 等。 如果使用 ButterKnife ，则必须在基类中定义抽象的setMyContentView() ，让 ButtertKnife 与视图绑定，否则在子类中会出现控件绑定不成功的情况，具体代码如下： 12345678910private void initLayout() &#123; setMyContentView(); ButterKnife.bind(this); &#125; /** * 由子类进行重写 * 在该方法中，子类指定布局文件 */ public abstract void setMyContentView(); 子类中实现该抽象方法 1234@Override public void setMyContentView() &#123; setContentView(R.layout.activity_login); &#125; 写了这个后，onCreate() 方法便不用再写了，具体的初始化操作，可以放在 init() 方法中，理清代码逻辑。 资源调用图片： 通常的图片放入drawable 文件夹中，在不做屏幕适配的情况下，建议放入xhdpi或xxhdpi文件夹中，mipmap 文件夹中通常放图标。 颜色资源： colorPrimary 、colorPrimaryDark 、colorAccent 需要指定，很多地方可以直接配置。 字符串与尺寸资源： title 、subtitle 、body 、caption 、largebody 等都可以指定。 优秀的第三方库 筛选菜单库： compile &#39;com.github.dongjunkun:DropDownMenu:1.0.3&#39; 坑 需要在 values 文件夹下新建interger.xml 1234&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;integer name="drop_down_menu_animation_duration"&gt;200&lt;/integer&gt;&lt;/resources&gt; 黄油刀注解： compile files(&#39;libs/butterknife-7.0.1.jar&#39;) 告别findViewById() 图片加载库： compile files(&#39;libs/universal-image-loader-1.9.2_sources.jar&#39;) 广告栏： compile &#39;cn.bingoogolapple:bga-banner:2.1.7@aar&#39; 解析json： compile files(&#39;libs/gson-2.6.2.jar&#39;) 底部导航栏： compile &#39;com.ashokvarma.android:bottom-navigation-bar:1.2.0&#39; 圆形头像： compile &#39;de.hdodenhof:circleimageview:2.1.0&#39; 可以弹出菜单的FAB： 1234/***添加rfab需要添加三个依赖***/ compile &apos;com.github.wangjiegulu:AndroidBucket:1.0.4&apos; compile &apos;com.github.wangjiegulu:AndroidInject:1.0.6&apos; compile &apos;com.github.wangjiegulu:RapidFloatingActionButton:1.0.3&apos; 强劲的后端支持 BmobBmob 官网 查询官方文档，可以方便的实现很多功能，对于移动开发提供了很多便利。 最美的 Material Design 设计作为 Android 开发者，当然是要推崇 MD 设计了，大量运用 MD 组件，采用 MD 图标，使用 MD 推荐的颜色。Material Design 官网 管理技术方面很多都可以通过搜索引擎来解决，但是管理这东西，真的不容易。想起我们的视频在答辩前10分钟才完成，文档写的很简陋，ppt不符合服务外包比赛的方向，这都是导致我们成绩不理想的原因。以后再参加类似比赛，如何能在15分钟左右时间内尽可能的展现出「创新点」、「比赛要求」、「技术运用」等干货才是最重要的，而不是说「产品历程」等无关痛痒的东西。 后记总之，经过这次项目以及担任 leader 的经历，自己的技术得到了提高，管理方面也有了自己的一点见解。继续前行吧！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown 语法学习]]></title>
      <url>%2F2017%2F04%2F09%2FMarkdown-%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[标题在 Markdown 中，你只需要在文本前面加上# ，通过设置# 的个数，来确定标题的级别 注意： # 与标题之间有一个空格 列表 文本1 文本2 文本3 只需要在文本前面加上- 、+ 、* 注意： - 与文本之间有一个空格 有序列表 文本1 文本2 文本3 只需要在文本前面加上1. 注意： 1. 与文本之间有一个空格 插入链接简书 格式为：[文本](链接) 插入图片格式为：![文本](图片链接) 插入下划线格式为：--- 引用 做自己喜欢的事 在文字前面加&gt; 粗体和斜体斜体 ：在文本前后各加一个* ，如：*文本* 粗体 ：在文本前后各加两个* ，如：**文本** 粗斜体 ：在文本前后各家三个* ,如：***文本*** 删除线我是删除线： 在文本前后各加两个~ ,如：~~文本~~ 代码引用 单行代码引用：hello world 使用 ` 将语句包起来 多行代码引用： 123public static void main(String[] args)&#123; System.out.println("hello world");&#125; 使用 ``` 将语句包起来 博客中插入图片插入图片 暂时先不采用「图床」的方式，直接加载本地图片解决吧。 插入表格 Name Sport Code Tian Basketball Java 用竖线| 将各个表格单元分开即可 结语这里只是暂时列出了几种最常用的 Markdown 语法，有一些高级语法，暂时还用不到，就先不写，等用到时再加以补充。以后写博客使用 Markdown + stormzhang 的排版标准来写，坚持下去，提高自己的写作能力。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GitHub + Hexo 搭建个人博客]]></title>
      <url>%2F2017%2F04%2F08%2FGithub-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[前言寒假的时候就想搭个博客玩了，一直没有具体实施。现在终于花费了 1 天的时间撘成了，心情还是有点小激动。以后就会将一些技术方面的文章、学习心得放到这里，这里就会成为我的「技术小天地」，希望自己技术能力得到提高，写作能力也能有长足的进步吧。 步骤概览 环境配置 Hexo 的安装、部署 NexT 主题的配置 绑定域名（可选） 环境配置 Git 的安装与配置 Git 的下载地址 Node.js 的安装 Node.js 的下载地址 注册 GitHub 账号 GitHub 的官网 配置 SSH key Linux 与 Mac 都是默认安装了 SSH ，而 Windows 系统安装了 Git Bash 应该也是带了 SSH 的。大家可以在终端（win 下在 Git Bash 里）输入 ssh ,如果出现以下提示证明你本机已经安装 SSH ，否则请自行安装 紧接着输入 ssh-keygen -t rsa ，指定 rsa 算法生成算法密钥，接着连续三个回车键（不需 要输入密码），然后会生成两个文件 id_ras 和 id_ras.pub ，而 id_ras 是密钥，id_ras.pub 是公钥。这两个文件默认分别在如下目录下生成： /c/Documents and Settings/username/.ssh 接着就是在 GitHub 上添加 SSH key ，相信大家会有办法的。 SSH key 添加成功后，输入ssh -T git@github.com 进行测试，如果出现以下提示证明添加成功了。 成功之后，我们就可以向 GitHub 提交代码，也可以部署我们的博客到 GitHub Page 上了。 搭建 GitHub Page 登录 GitHub 后，新建一个仓库。仓库名为 username.github.io username 为你自己的用户名，这是特殊的词法约定。 注意 ：仓库中必须有文件才可以访问，你可以先添加一个Readme文件 Hexo 的安装、部署Hexo 是一个简单、快速、强大的静态博客生成工具，支持 Markdown 格式。 这里是官方介绍 在任意一个盘符，新建「hexo」文件夹，比如我在D盘新建，作为 博客的文件夹。 打开 Git Bash ，运行 Hexo 安装命令 npm install -g hexo ps: 这里 npm(node package management) 在安装 Node.js 的时候已经默认安装 进入 hexo 目录下 cd D:/hexo 运行以下命令，Hexo 随后将自动在目标文件夹中国建立网站所需要的所有文件。 hexo init 搭建一个本地博客 hexo g 生成博客 hexo s 启动本地服务预览 hexo s -g 两者也可以合并起来 hexo deploy 可以将本地博客上传至 Git 仓库 然后在浏览器中输入「localhost:4000」即可预览已生成的博客 新建文章并部署到 Github hexo new 「文档名」 在 source/_post 目录下生成对应的 .md 文档 hexo d -g 即可以生成文档并将文档部署到 Github NexT 主题的安装、配置原有的主题是landscape ，但是不一定符合所有人的喜好，可以更换主题，让自己的博客更具个性化，这里我选用了简洁大方的 NexT 主题，来打造我的博客，当然也有其他好看的主题，大家可以自行安装、配置。 一些 Hexo 博客主题推荐 NexT 主题安装配置 NexT 主题官方配置说明 注意： 其实按着官方配置说明没什么大问题，但又几个坑需要注意： _config 文件中修改的时候，注意加空格 写 Markdown 文件的时候，tag 、categories 的时候也一定要加空格，或者写成如下形式： 12345tag:- Java- Androidcategories:- Tech 设置logo 主题配置文件中 favicon: images/logo.png 添加评论 添加评论的话，不要用多说（快要关闭了），改用 disqus 添加阅读量 阅读量 设置 RSS 功能，需要下载插件 设置RSS 绑定域名（可选）作为一个技术博客，怎么能甘心依附于一个二级域名呢？去阿里云上买一个域名，添加解析，然后在自己的本地文件中也添加好解析，便大功告成，具体步骤可以参考这篇文章。 Hexo 博客绑定域名 后记大致功能就这样，只要善用搜索引擎，没有什么问题解决不了的。坚持下去，记录自己学习的点滴。 ###]]></content>
    </entry>

    
  
  
</search>
